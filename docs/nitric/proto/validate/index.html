<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nitric.proto.validate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nitric.proto.validate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2021 Nitric Technologies Pty Ltd.
#
# This file is part of Nitric Python 3 SDK.
# See https://github.com/nitrictech/python-sdk for further info.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: validate/validate.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import List

import betterproto


class KnownRegex(betterproto.Enum):
    &#34;&#34;&#34;WellKnownRegex contain some well-known patterns.&#34;&#34;&#34;

    UNKNOWN = 0
    HTTP_HEADER_NAME = 1
    &#34;&#34;&#34;HTTP header name as defined by RFC 7230.&#34;&#34;&#34;

    HTTP_HEADER_VALUE = 2
    &#34;&#34;&#34;HTTP header value as defined by RFC 7230.&#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class FieldRules(betterproto.Message):
    &#34;&#34;&#34;
    FieldRules encapsulates the rules for each type of field. Depending on the
    field, the correct set should be used to ensure proper validations.
    &#34;&#34;&#34;

    message: &#34;MessageRules&#34; = betterproto.message_field(17)
    float: &#34;FloatRules&#34; = betterproto.message_field(1, group=&#34;type&#34;)
    &#34;&#34;&#34;Scalar Field Types&#34;&#34;&#34;

    double: &#34;DoubleRules&#34; = betterproto.message_field(2, group=&#34;type&#34;)
    int32: &#34;Int32Rules&#34; = betterproto.message_field(3, group=&#34;type&#34;)
    int64: &#34;Int64Rules&#34; = betterproto.message_field(4, group=&#34;type&#34;)
    uint32: &#34;UInt32Rules&#34; = betterproto.message_field(5, group=&#34;type&#34;)
    uint64: &#34;UInt64Rules&#34; = betterproto.message_field(6, group=&#34;type&#34;)
    sint32: &#34;SInt32Rules&#34; = betterproto.message_field(7, group=&#34;type&#34;)
    sint64: &#34;SInt64Rules&#34; = betterproto.message_field(8, group=&#34;type&#34;)
    fixed32: &#34;Fixed32Rules&#34; = betterproto.message_field(9, group=&#34;type&#34;)
    fixed64: &#34;Fixed64Rules&#34; = betterproto.message_field(10, group=&#34;type&#34;)
    sfixed32: &#34;SFixed32Rules&#34; = betterproto.message_field(11, group=&#34;type&#34;)
    sfixed64: &#34;SFixed64Rules&#34; = betterproto.message_field(12, group=&#34;type&#34;)
    bool: &#34;BoolRules&#34; = betterproto.message_field(13, group=&#34;type&#34;)
    string: &#34;StringRules&#34; = betterproto.message_field(14, group=&#34;type&#34;)
    bytes: &#34;BytesRules&#34; = betterproto.message_field(15, group=&#34;type&#34;)
    enum: &#34;EnumRules&#34; = betterproto.message_field(16, group=&#34;type&#34;)
    &#34;&#34;&#34;Complex Field Types&#34;&#34;&#34;

    repeated: &#34;RepeatedRules&#34; = betterproto.message_field(18, group=&#34;type&#34;)
    map: &#34;MapRules&#34; = betterproto.message_field(19, group=&#34;type&#34;)
    any: &#34;AnyRules&#34; = betterproto.message_field(20, group=&#34;type&#34;)
    &#34;&#34;&#34;Well-Known Field Types&#34;&#34;&#34;

    duration: &#34;DurationRules&#34; = betterproto.message_field(21, group=&#34;type&#34;)
    timestamp: &#34;TimestampRules&#34; = betterproto.message_field(22, group=&#34;type&#34;)


@dataclass(eq=False, repr=False)
class FloatRules(betterproto.Message):
    &#34;&#34;&#34;FloatRules describes the constraints applied to `float` values&#34;&#34;&#34;

    const: float = betterproto.float_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: float = betterproto.float_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: float = betterproto.float_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: float = betterproto.float_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: float = betterproto.float_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[float] = betterproto.float_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[float] = betterproto.float_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class DoubleRules(betterproto.Message):
    &#34;&#34;&#34;DoubleRules describes the constraints applied to `double` values&#34;&#34;&#34;

    const: float = betterproto.double_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: float = betterproto.double_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: float = betterproto.double_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: float = betterproto.double_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: float = betterproto.double_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[float] = betterproto.double_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[float] = betterproto.double_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class Int32Rules(betterproto.Message):
    &#34;&#34;&#34;Int32Rules describes the constraints applied to `int32` values&#34;&#34;&#34;

    const: int = betterproto.int32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.int32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.int32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.int32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.int32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class Int64Rules(betterproto.Message):
    &#34;&#34;&#34;Int64Rules describes the constraints applied to `int64` values&#34;&#34;&#34;

    const: int = betterproto.int64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.int64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.int64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.int64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.int64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class UInt32Rules(betterproto.Message):
    &#34;&#34;&#34;UInt32Rules describes the constraints applied to `uint32` values&#34;&#34;&#34;

    const: int = betterproto.uint32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.uint32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.uint32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.uint32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.uint32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.uint32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.uint32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class UInt64Rules(betterproto.Message):
    &#34;&#34;&#34;UInt64Rules describes the constraints applied to `uint64` values&#34;&#34;&#34;

    const: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.uint64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.uint64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.uint64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.uint64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class SInt32Rules(betterproto.Message):
    &#34;&#34;&#34;SInt32Rules describes the constraints applied to `sint32` values&#34;&#34;&#34;

    const: int = betterproto.sint32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sint32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sint32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sint32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sint32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sint32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sint32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class SInt64Rules(betterproto.Message):
    &#34;&#34;&#34;SInt64Rules describes the constraints applied to `sint64` values&#34;&#34;&#34;

    const: int = betterproto.sint64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sint64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sint64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sint64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sint64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sint64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sint64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class Fixed32Rules(betterproto.Message):
    &#34;&#34;&#34;Fixed32Rules describes the constraints applied to `fixed32` values&#34;&#34;&#34;

    const: int = betterproto.fixed32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.fixed32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.fixed32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.fixed32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.fixed32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.fixed32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.fixed32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class Fixed64Rules(betterproto.Message):
    &#34;&#34;&#34;Fixed64Rules describes the constraints applied to `fixed64` values&#34;&#34;&#34;

    const: int = betterproto.fixed64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.fixed64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.fixed64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.fixed64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.fixed64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.fixed64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.fixed64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class SFixed32Rules(betterproto.Message):
    &#34;&#34;&#34;SFixed32Rules describes the constraints applied to `sfixed32` values&#34;&#34;&#34;

    const: int = betterproto.sfixed32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sfixed32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sfixed32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sfixed32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sfixed32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sfixed32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sfixed32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class SFixed64Rules(betterproto.Message):
    &#34;&#34;&#34;SFixed64Rules describes the constraints applied to `sfixed64` values&#34;&#34;&#34;

    const: int = betterproto.sfixed64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sfixed64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sfixed64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sfixed64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sfixed64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sfixed64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sfixed64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class BoolRules(betterproto.Message):
    &#34;&#34;&#34;BoolRules describes the constraints applied to `bool` values&#34;&#34;&#34;

    const: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class StringRules(betterproto.Message):
    &#34;&#34;&#34;StringRules describe the constraints applied to `string` values&#34;&#34;&#34;

    const: str = betterproto.string_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    len: int = betterproto.uint64_field(19)
    &#34;&#34;&#34;
    Len specifies that this field must be the specified number of characters
    (Unicode code points). Note that the number of characters may differ from
    the number of bytes in the string.
    &#34;&#34;&#34;

    min_len: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MinLen specifies that this field must be the specified number of characters
    (Unicode code points) at a minimum. Note that the number of characters may
    differ from the number of bytes in the string.
    &#34;&#34;&#34;

    max_len: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    MaxLen specifies that this field must be the specified number of characters
    (Unicode code points) at a maximum. Note that the number of characters may
    differ from the number of bytes in the string.
    &#34;&#34;&#34;

    len_bytes: int = betterproto.uint64_field(20)
    &#34;&#34;&#34;
    LenBytes specifies that this field must be the specified number of bytes at
    a minimum
    &#34;&#34;&#34;

    min_bytes: int = betterproto.uint64_field(4)
    &#34;&#34;&#34;
    MinBytes specifies that this field must be the specified number of bytes at
    a minimum
    &#34;&#34;&#34;

    max_bytes: int = betterproto.uint64_field(5)
    &#34;&#34;&#34;
    MaxBytes specifies that this field must be the specified number of bytes at
    a maximum
    &#34;&#34;&#34;

    pattern: str = betterproto.string_field(6)
    &#34;&#34;&#34;
    Pattern specifes that this field must match against the specified regular
    expression (RE2 syntax). The included expression should elide any
    delimiters.
    &#34;&#34;&#34;

    prefix: str = betterproto.string_field(7)
    &#34;&#34;&#34;
    Prefix specifies that this field must have the specified substring at the
    beginning of the string.
    &#34;&#34;&#34;

    suffix: str = betterproto.string_field(8)
    &#34;&#34;&#34;
    Suffix specifies that this field must have the specified substring at the
    end of the string.
    &#34;&#34;&#34;

    contains: str = betterproto.string_field(9)
    &#34;&#34;&#34;
    Contains specifies that this field must have the specified substring
    anywhere in the string.
    &#34;&#34;&#34;

    not_contains: str = betterproto.string_field(23)
    &#34;&#34;&#34;
    NotContains specifies that this field cannot have the specified substring
    anywhere in the string.
    &#34;&#34;&#34;

    in_: List[str] = betterproto.string_field(10)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[str] = betterproto.string_field(11)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    email: bool = betterproto.bool_field(12, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Email specifies that the field must be a valid email address as defined by
    RFC 5322
    &#34;&#34;&#34;

    hostname: bool = betterproto.bool_field(13, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Hostname specifies that the field must be a valid hostname as defined by
    RFC 1034. This constraint does not support internationalized domain names
    (IDNs).
    &#34;&#34;&#34;

    ip: bool = betterproto.bool_field(14, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ip specifies that the field must be a valid IP (v4 or v6) address. Valid
    IPv6 addresses should not include surrounding square brackets.
    &#34;&#34;&#34;

    ipv4: bool = betterproto.bool_field(15, group=&#34;well_known&#34;)
    &#34;&#34;&#34;Ipv4 specifies that the field must be a valid IPv4 address.&#34;&#34;&#34;

    ipv6: bool = betterproto.bool_field(16, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv6 specifies that the field must be a valid IPv6 address. Valid IPv6
    addresses should not include surrounding square brackets.
    &#34;&#34;&#34;

    uri: bool = betterproto.bool_field(17, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Uri specifies that the field must be a valid, absolute URI as defined by
    RFC 3986
    &#34;&#34;&#34;

    uri_ref: bool = betterproto.bool_field(18, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    UriRef specifies that the field must be a valid URI as defined by RFC 3986
    and may be relative or absolute.
    &#34;&#34;&#34;

    address: bool = betterproto.bool_field(21, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Address specifies that the field must be either a valid hostname as defined
    by RFC 1034 (which does not support internationalized domain names or
    IDNs), or it can be a valid IP (v4 or v6).
    &#34;&#34;&#34;

    uuid: bool = betterproto.bool_field(22, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Uuid specifies that the field must be a valid UUID as defined by RFC 4122
    &#34;&#34;&#34;

    well_known_regex: &#34;KnownRegex&#34; = betterproto.enum_field(24, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    WellKnownRegex specifies a common well known pattern defined as a regex.
    &#34;&#34;&#34;

    strict: bool = betterproto.bool_field(25)
    &#34;&#34;&#34;
    This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
    strict header validation. By default, this is true, and HTTP header
    validations are RFC-compliant. Setting to false will enable a looser
    validations that only disallows \r\n\0 characters, which can be used to
    bypass header matching rules.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(26)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class BytesRules(betterproto.Message):
    &#34;&#34;&#34;BytesRules describe the constraints applied to `bytes` values&#34;&#34;&#34;

    const: bytes = betterproto.bytes_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    len: int = betterproto.uint64_field(13)
    &#34;&#34;&#34;Len specifies that this field must be the specified number of bytes&#34;&#34;&#34;

    min_len: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MinLen specifies that this field must be the specified number of bytes at a
    minimum
    &#34;&#34;&#34;

    max_len: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    MaxLen specifies that this field must be the specified number of bytes at a
    maximum
    &#34;&#34;&#34;

    pattern: str = betterproto.string_field(4)
    &#34;&#34;&#34;
    Pattern specifes that this field must match against the specified regular
    expression (RE2 syntax). The included expression should elide any
    delimiters.
    &#34;&#34;&#34;

    prefix: bytes = betterproto.bytes_field(5)
    &#34;&#34;&#34;
    Prefix specifies that this field must have the specified bytes at the
    beginning of the string.
    &#34;&#34;&#34;

    suffix: bytes = betterproto.bytes_field(6)
    &#34;&#34;&#34;
    Suffix specifies that this field must have the specified bytes at the end
    of the string.
    &#34;&#34;&#34;

    contains: bytes = betterproto.bytes_field(7)
    &#34;&#34;&#34;
    Contains specifies that this field must have the specified bytes anywhere
    in the string.
    &#34;&#34;&#34;

    in_: List[bytes] = betterproto.bytes_field(8)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[bytes] = betterproto.bytes_field(9)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ip: bool = betterproto.bool_field(10, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ip specifies that the field must be a valid IP (v4 or v6) address in byte
    format
    &#34;&#34;&#34;

    ipv4: bool = betterproto.bool_field(11, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv4 specifies that the field must be a valid IPv4 address in byte format
    &#34;&#34;&#34;

    ipv6: bool = betterproto.bool_field(12, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv6 specifies that the field must be a valid IPv6 address in byte format
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(14)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class EnumRules(betterproto.Message):
    &#34;&#34;&#34;EnumRules describe the constraints applied to enum values&#34;&#34;&#34;

    const: int = betterproto.int32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    defined_only: bool = betterproto.bool_field(2)
    &#34;&#34;&#34;
    DefinedOnly specifies that this field must be only one of the defined
    values for this enum, failing on any undefined value.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int32_field(3)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int32_field(4)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class MessageRules(betterproto.Message):
    &#34;&#34;&#34;
    MessageRules describe the constraints applied to embedded message values.
    For message-type fields, validation is performed recursively.
    &#34;&#34;&#34;

    skip: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;
    Skip specifies that the validation rules of this field should not be
    evaluated
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(2)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class RepeatedRules(betterproto.Message):
    &#34;&#34;&#34;RepeatedRules describe the constraints applied to `repeated` values&#34;&#34;&#34;

    min_items: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;
    MinItems specifies that this field must have the specified number of items
    at a minimum
    &#34;&#34;&#34;

    max_items: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MaxItems specifies that this field must have the specified number of items
    at a maximum
    &#34;&#34;&#34;

    unique: bool = betterproto.bool_field(3)
    &#34;&#34;&#34;
    Unique specifies that all elements in this field must be unique. This
    contraint is only applicable to scalar and enum types (messages are not
    supported).
    &#34;&#34;&#34;

    items: &#34;FieldRules&#34; = betterproto.message_field(4)
    &#34;&#34;&#34;
    Items specifies the contraints to be applied to each item in the field.
    Repeated message fields will still execute validation against each item
    unless skip is specified here.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(5)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class MapRules(betterproto.Message):
    &#34;&#34;&#34;MapRules describe the constraints applied to `map` values&#34;&#34;&#34;

    min_pairs: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;
    MinPairs specifies that this field must have the specified number of KVs at
    a minimum
    &#34;&#34;&#34;

    max_pairs: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MaxPairs specifies that this field must have the specified number of KVs at
    a maximum
    &#34;&#34;&#34;

    no_sparse: bool = betterproto.bool_field(3)
    &#34;&#34;&#34;
    NoSparse specifies values in this field cannot be unset. This only applies
    to map&#39;s with message value types.
    &#34;&#34;&#34;

    keys: &#34;FieldRules&#34; = betterproto.message_field(4)
    &#34;&#34;&#34;
    Keys specifies the constraints to be applied to each key in the field.
    &#34;&#34;&#34;

    values: &#34;FieldRules&#34; = betterproto.message_field(5)
    &#34;&#34;&#34;
    Values specifies the constraints to be applied to the value of each key in
    the field. Message values will still have their validations evaluated
    unless skip is specified here.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(6)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class AnyRules(betterproto.Message):
    &#34;&#34;&#34;
    AnyRules describe constraints applied exclusively to the
    `google.protobuf.Any` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    in_: List[str] = betterproto.string_field(2)
    &#34;&#34;&#34;
    In specifies that this field&#39;s `type_url` must be equal to one of the
    specified values.
    &#34;&#34;&#34;

    not_in: List[str] = betterproto.string_field(3)
    &#34;&#34;&#34;
    NotIn specifies that this field&#39;s `type_url` must not be equal to any of
    the specified values.
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class DurationRules(betterproto.Message):
    &#34;&#34;&#34;
    DurationRules describe the constraints applied exclusively to the
    `google.protobuf.Duration` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    const: timedelta = betterproto.message_field(2)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: timedelta = betterproto.message_field(3)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: timedelta = betterproto.message_field(4)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    inclusive
    &#34;&#34;&#34;

    gt: timedelta = betterproto.message_field(5)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive
    &#34;&#34;&#34;

    gte: timedelta = betterproto.message_field(6)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than the specified value,
    inclusive
    &#34;&#34;&#34;

    in_: List[timedelta] = betterproto.message_field(7)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[timedelta] = betterproto.message_field(8)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;


@dataclass(eq=False, repr=False)
class TimestampRules(betterproto.Message):
    &#34;&#34;&#34;
    TimestampRules describe the constraints applied exclusively to the
    `google.protobuf.Timestamp` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    const: datetime = betterproto.message_field(2)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: datetime = betterproto.message_field(3)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: datetime = betterproto.message_field(4)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than the specified value,
    inclusive
    &#34;&#34;&#34;

    gt: datetime = betterproto.message_field(5)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive
    &#34;&#34;&#34;

    gte: datetime = betterproto.message_field(6)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than the specified value,
    inclusive
    &#34;&#34;&#34;

    lt_now: bool = betterproto.bool_field(7)
    &#34;&#34;&#34;
    LtNow specifies that this must be less than the current time. LtNow can
    only be used with the Within rule.
    &#34;&#34;&#34;

    gt_now: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    GtNow specifies that this must be greater than the current time. GtNow can
    only be used with the Within rule.
    &#34;&#34;&#34;

    within: timedelta = betterproto.message_field(9)
    &#34;&#34;&#34;
    Within specifies that this field must be within this duration of the
    current time. This constraint can be used alone or with the LtNow and GtNow
    rules.
    &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nitric.proto.validate.AnyRules"><code class="flex name class">
<span>class <span class="ident">AnyRules</span></span>
<span>(</span><span>required: bool = &lt;object object&gt;, in_: List[str] = &lt;object object&gt;, not_in: List[str] = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>AnyRules describe constraints applied exclusively to the
<code>google.protobuf.Any</code> well-known type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class AnyRules(betterproto.Message):
    &#34;&#34;&#34;
    AnyRules describe constraints applied exclusively to the
    `google.protobuf.Any` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    in_: List[str] = betterproto.string_field(2)
    &#34;&#34;&#34;
    In specifies that this field&#39;s `type_url` must be equal to one of the
    specified values.
    &#34;&#34;&#34;

    not_in: List[str] = betterproto.string_field(3)
    &#34;&#34;&#34;
    NotIn specifies that this field&#39;s `type_url` must not be equal to any of
    the specified values.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.AnyRules.in_"><code class="name">var <span class="ident">in_</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field's <code>type_url</code> must be equal to one of the
specified values.</p></div>
</dd>
<dt id="nitric.proto.validate.AnyRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field's <code>type_url</code> must not be equal to any of
the specified values.</p></div>
</dd>
<dt id="nitric.proto.validate.AnyRules.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"><p>Required specifies that this field must be set</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.BoolRules"><code class="flex name class">
<span>class <span class="ident">BoolRules</span></span>
<span>(</span><span>const: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>BoolRules describes the constraints applied to <code>bool</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class BoolRules(betterproto.Message):
    &#34;&#34;&#34;BoolRules describes the constraints applied to `bool` values&#34;&#34;&#34;

    const: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.BoolRules.const"><code class="name">var <span class="ident">const</span> : bool</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.BytesRules"><code class="flex name class">
<span>class <span class="ident">BytesRules</span></span>
<span>(</span><span>const: bytes = &lt;object object&gt;, len: int = &lt;object object&gt;, min_len: int = &lt;object object&gt;, max_len: int = &lt;object object&gt;, pattern: str = &lt;object object&gt;, prefix: bytes = &lt;object object&gt;, suffix: bytes = &lt;object object&gt;, contains: bytes = &lt;object object&gt;, in_: List[bytes] = &lt;object object&gt;, not_in: List[bytes] = &lt;object object&gt;, ip: bool = &lt;object object&gt;, ipv4: bool = &lt;object object&gt;, ipv6: bool = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>BytesRules describe the constraints applied to <code>bytes</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class BytesRules(betterproto.Message):
    &#34;&#34;&#34;BytesRules describe the constraints applied to `bytes` values&#34;&#34;&#34;

    const: bytes = betterproto.bytes_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    len: int = betterproto.uint64_field(13)
    &#34;&#34;&#34;Len specifies that this field must be the specified number of bytes&#34;&#34;&#34;

    min_len: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MinLen specifies that this field must be the specified number of bytes at a
    minimum
    &#34;&#34;&#34;

    max_len: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    MaxLen specifies that this field must be the specified number of bytes at a
    maximum
    &#34;&#34;&#34;

    pattern: str = betterproto.string_field(4)
    &#34;&#34;&#34;
    Pattern specifes that this field must match against the specified regular
    expression (RE2 syntax). The included expression should elide any
    delimiters.
    &#34;&#34;&#34;

    prefix: bytes = betterproto.bytes_field(5)
    &#34;&#34;&#34;
    Prefix specifies that this field must have the specified bytes at the
    beginning of the string.
    &#34;&#34;&#34;

    suffix: bytes = betterproto.bytes_field(6)
    &#34;&#34;&#34;
    Suffix specifies that this field must have the specified bytes at the end
    of the string.
    &#34;&#34;&#34;

    contains: bytes = betterproto.bytes_field(7)
    &#34;&#34;&#34;
    Contains specifies that this field must have the specified bytes anywhere
    in the string.
    &#34;&#34;&#34;

    in_: List[bytes] = betterproto.bytes_field(8)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[bytes] = betterproto.bytes_field(9)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ip: bool = betterproto.bool_field(10, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ip specifies that the field must be a valid IP (v4 or v6) address in byte
    format
    &#34;&#34;&#34;

    ipv4: bool = betterproto.bool_field(11, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv4 specifies that the field must be a valid IPv4 address in byte format
    &#34;&#34;&#34;

    ipv6: bool = betterproto.bool_field(12, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv6 specifies that the field must be a valid IPv6 address in byte format
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(14)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.BytesRules.const"><code class="name">var <span class="ident">const</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.contains"><code class="name">var <span class="ident">contains</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Contains specifies that this field must have the specified bytes anywhere
in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.in_"><code class="name">var <span class="ident">in_</span> : List[bytes]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.ip"><code class="name">var <span class="ident">ip</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ip specifies that the field must be a valid IP (v4 or v6) address in byte
format</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.ipv4"><code class="name">var <span class="ident">ipv4</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ipv4 specifies that the field must be a valid IPv4 address in byte format</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.ipv6"><code class="name">var <span class="ident">ipv6</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ipv6 specifies that the field must be a valid IPv6 address in byte format</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.len"><code class="name">var <span class="ident">len</span> : int</code></dt>
<dd>
<div class="desc"><p>Len specifies that this field must be the specified number of bytes</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.max_len"><code class="name">var <span class="ident">max_len</span> : int</code></dt>
<dd>
<div class="desc"><p>MaxLen specifies that this field must be the specified number of bytes at a
maximum</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.min_len"><code class="name">var <span class="ident">min_len</span> : int</code></dt>
<dd>
<div class="desc"><p>MinLen specifies that this field must be the specified number of bytes at a
minimum</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[bytes]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.pattern"><code class="name">var <span class="ident">pattern</span> : str</code></dt>
<dd>
<div class="desc"><p>Pattern specifes that this field must match against the specified regular
expression (RE2 syntax). The included expression should elide any
delimiters.</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.prefix"><code class="name">var <span class="ident">prefix</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Prefix specifies that this field must have the specified bytes at the
beginning of the string.</p></div>
</dd>
<dt id="nitric.proto.validate.BytesRules.suffix"><code class="name">var <span class="ident">suffix</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Suffix specifies that this field must have the specified bytes at the end
of the string.</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.DoubleRules"><code class="flex name class">
<span>class <span class="ident">DoubleRules</span></span>
<span>(</span><span>const: float = &lt;object object&gt;, lt: float = &lt;object object&gt;, lte: float = &lt;object object&gt;, gt: float = &lt;object object&gt;, gte: float = &lt;object object&gt;, in_: List[float] = &lt;object object&gt;, not_in: List[float] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>DoubleRules describes the constraints applied to <code>double</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class DoubleRules(betterproto.Message):
    &#34;&#34;&#34;DoubleRules describes the constraints applied to `double` values&#34;&#34;&#34;

    const: float = betterproto.double_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: float = betterproto.double_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: float = betterproto.double_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: float = betterproto.double_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: float = betterproto.double_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[float] = betterproto.double_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[float] = betterproto.double_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.DoubleRules.const"><code class="name">var <span class="ident">const</span> : float</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.gt"><code class="name">var <span class="ident">gt</span> : float</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.gte"><code class="name">var <span class="ident">gte</span> : float</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.in_"><code class="name">var <span class="ident">in_</span> : List[float]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.lt"><code class="name">var <span class="ident">lt</span> : float</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.lte"><code class="name">var <span class="ident">lte</span> : float</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DoubleRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[float]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.DurationRules"><code class="flex name class">
<span>class <span class="ident">DurationRules</span></span>
<span>(</span><span>required: bool = &lt;object object&gt;, const: datetime.timedelta = &lt;object object&gt;, lt: datetime.timedelta = &lt;object object&gt;, lte: datetime.timedelta = &lt;object object&gt;, gt: datetime.timedelta = &lt;object object&gt;, gte: datetime.timedelta = &lt;object object&gt;, in_: List[datetime.timedelta] = &lt;object object&gt;, not_in: List[datetime.timedelta] = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>DurationRules describe the constraints applied exclusively to the
<code>google.protobuf.Duration</code> well-known type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class DurationRules(betterproto.Message):
    &#34;&#34;&#34;
    DurationRules describe the constraints applied exclusively to the
    `google.protobuf.Duration` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    const: timedelta = betterproto.message_field(2)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: timedelta = betterproto.message_field(3)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: timedelta = betterproto.message_field(4)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    inclusive
    &#34;&#34;&#34;

    gt: timedelta = betterproto.message_field(5)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive
    &#34;&#34;&#34;

    gte: timedelta = betterproto.message_field(6)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than the specified value,
    inclusive
    &#34;&#34;&#34;

    in_: List[timedelta] = betterproto.message_field(7)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[timedelta] = betterproto.message_field(8)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.DurationRules.const"><code class="name">var <span class="ident">const</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.gt"><code class="name">var <span class="ident">gt</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.gte"><code class="name">var <span class="ident">gte</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than the specified value,
inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.in_"><code class="name">var <span class="ident">in_</span> : List[datetime.timedelta]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.lt"><code class="name">var <span class="ident">lt</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.lte"><code class="name">var <span class="ident">lte</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[datetime.timedelta]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
<dt id="nitric.proto.validate.DurationRules.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"><p>Required specifies that this field must be set</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.EnumRules"><code class="flex name class">
<span>class <span class="ident">EnumRules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, defined_only: bool = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>EnumRules describe the constraints applied to enum values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class EnumRules(betterproto.Message):
    &#34;&#34;&#34;EnumRules describe the constraints applied to enum values&#34;&#34;&#34;

    const: int = betterproto.int32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    defined_only: bool = betterproto.bool_field(2)
    &#34;&#34;&#34;
    DefinedOnly specifies that this field must be only one of the defined
    values for this enum, failing on any undefined value.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int32_field(3)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int32_field(4)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.EnumRules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.EnumRules.defined_only"><code class="name">var <span class="ident">defined_only</span> : bool</code></dt>
<dd>
<div class="desc"><p>DefinedOnly specifies that this field must be only one of the defined
values for this enum, failing on any undefined value.</p></div>
</dd>
<dt id="nitric.proto.validate.EnumRules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.EnumRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.FieldRules"><code class="flex name class">
<span>class <span class="ident">FieldRules</span></span>
<span>(</span><span>message: <a title="nitric.proto.validate.MessageRules" href="#nitric.proto.validate.MessageRules">MessageRules</a> = &lt;object object&gt;, float: <a title="nitric.proto.validate.FloatRules" href="#nitric.proto.validate.FloatRules">FloatRules</a> = &lt;object object&gt;, double: <a title="nitric.proto.validate.DoubleRules" href="#nitric.proto.validate.DoubleRules">DoubleRules</a> = &lt;object object&gt;, int32: <a title="nitric.proto.validate.Int32Rules" href="#nitric.proto.validate.Int32Rules">Int32Rules</a> = &lt;object object&gt;, int64: <a title="nitric.proto.validate.Int64Rules" href="#nitric.proto.validate.Int64Rules">Int64Rules</a> = &lt;object object&gt;, uint32: <a title="nitric.proto.validate.UInt32Rules" href="#nitric.proto.validate.UInt32Rules">UInt32Rules</a> = &lt;object object&gt;, uint64: <a title="nitric.proto.validate.UInt64Rules" href="#nitric.proto.validate.UInt64Rules">UInt64Rules</a> = &lt;object object&gt;, sint32: <a title="nitric.proto.validate.SInt32Rules" href="#nitric.proto.validate.SInt32Rules">SInt32Rules</a> = &lt;object object&gt;, sint64: <a title="nitric.proto.validate.SInt64Rules" href="#nitric.proto.validate.SInt64Rules">SInt64Rules</a> = &lt;object object&gt;, fixed32: <a title="nitric.proto.validate.Fixed32Rules" href="#nitric.proto.validate.Fixed32Rules">Fixed32Rules</a> = &lt;object object&gt;, fixed64: <a title="nitric.proto.validate.Fixed64Rules" href="#nitric.proto.validate.Fixed64Rules">Fixed64Rules</a> = &lt;object object&gt;, sfixed32: <a title="nitric.proto.validate.SFixed32Rules" href="#nitric.proto.validate.SFixed32Rules">SFixed32Rules</a> = &lt;object object&gt;, sfixed64: <a title="nitric.proto.validate.SFixed64Rules" href="#nitric.proto.validate.SFixed64Rules">SFixed64Rules</a> = &lt;object object&gt;, bool: <a title="nitric.proto.validate.BoolRules" href="#nitric.proto.validate.BoolRules">BoolRules</a> = &lt;object object&gt;, string: <a title="nitric.proto.validate.StringRules" href="#nitric.proto.validate.StringRules">StringRules</a> = &lt;object object&gt;, bytes: <a title="nitric.proto.validate.BytesRules" href="#nitric.proto.validate.BytesRules">BytesRules</a> = &lt;object object&gt;, enum: <a title="nitric.proto.validate.EnumRules" href="#nitric.proto.validate.EnumRules">EnumRules</a> = &lt;object object&gt;, repeated: <a title="nitric.proto.validate.RepeatedRules" href="#nitric.proto.validate.RepeatedRules">RepeatedRules</a> = &lt;object object&gt;, map: <a title="nitric.proto.validate.MapRules" href="#nitric.proto.validate.MapRules">MapRules</a> = &lt;object object&gt;, any: <a title="nitric.proto.validate.AnyRules" href="#nitric.proto.validate.AnyRules">AnyRules</a> = &lt;object object&gt;, duration: <a title="nitric.proto.validate.DurationRules" href="#nitric.proto.validate.DurationRules">DurationRules</a> = &lt;object object&gt;, timestamp: <a title="nitric.proto.validate.TimestampRules" href="#nitric.proto.validate.TimestampRules">TimestampRules</a> = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>FieldRules encapsulates the rules for each type of field. Depending on the
field, the correct set should be used to ensure proper validations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class FieldRules(betterproto.Message):
    &#34;&#34;&#34;
    FieldRules encapsulates the rules for each type of field. Depending on the
    field, the correct set should be used to ensure proper validations.
    &#34;&#34;&#34;

    message: &#34;MessageRules&#34; = betterproto.message_field(17)
    float: &#34;FloatRules&#34; = betterproto.message_field(1, group=&#34;type&#34;)
    &#34;&#34;&#34;Scalar Field Types&#34;&#34;&#34;

    double: &#34;DoubleRules&#34; = betterproto.message_field(2, group=&#34;type&#34;)
    int32: &#34;Int32Rules&#34; = betterproto.message_field(3, group=&#34;type&#34;)
    int64: &#34;Int64Rules&#34; = betterproto.message_field(4, group=&#34;type&#34;)
    uint32: &#34;UInt32Rules&#34; = betterproto.message_field(5, group=&#34;type&#34;)
    uint64: &#34;UInt64Rules&#34; = betterproto.message_field(6, group=&#34;type&#34;)
    sint32: &#34;SInt32Rules&#34; = betterproto.message_field(7, group=&#34;type&#34;)
    sint64: &#34;SInt64Rules&#34; = betterproto.message_field(8, group=&#34;type&#34;)
    fixed32: &#34;Fixed32Rules&#34; = betterproto.message_field(9, group=&#34;type&#34;)
    fixed64: &#34;Fixed64Rules&#34; = betterproto.message_field(10, group=&#34;type&#34;)
    sfixed32: &#34;SFixed32Rules&#34; = betterproto.message_field(11, group=&#34;type&#34;)
    sfixed64: &#34;SFixed64Rules&#34; = betterproto.message_field(12, group=&#34;type&#34;)
    bool: &#34;BoolRules&#34; = betterproto.message_field(13, group=&#34;type&#34;)
    string: &#34;StringRules&#34; = betterproto.message_field(14, group=&#34;type&#34;)
    bytes: &#34;BytesRules&#34; = betterproto.message_field(15, group=&#34;type&#34;)
    enum: &#34;EnumRules&#34; = betterproto.message_field(16, group=&#34;type&#34;)
    &#34;&#34;&#34;Complex Field Types&#34;&#34;&#34;

    repeated: &#34;RepeatedRules&#34; = betterproto.message_field(18, group=&#34;type&#34;)
    map: &#34;MapRules&#34; = betterproto.message_field(19, group=&#34;type&#34;)
    any: &#34;AnyRules&#34; = betterproto.message_field(20, group=&#34;type&#34;)
    &#34;&#34;&#34;Well-Known Field Types&#34;&#34;&#34;

    duration: &#34;DurationRules&#34; = betterproto.message_field(21, group=&#34;type&#34;)
    timestamp: &#34;TimestampRules&#34; = betterproto.message_field(22, group=&#34;type&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.FieldRules.any"><code class="name">var <span class="ident">any</span> : <a title="nitric.proto.validate.AnyRules" href="#nitric.proto.validate.AnyRules">AnyRules</a></code></dt>
<dd>
<div class="desc"><p>Well-Known Field Types</p></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.bool"><code class="name">var <span class="ident">bool</span> : <a title="nitric.proto.validate.BoolRules" href="#nitric.proto.validate.BoolRules">BoolRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.bytes"><code class="name">var <span class="ident">bytes</span> : <a title="nitric.proto.validate.BytesRules" href="#nitric.proto.validate.BytesRules">BytesRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.double"><code class="name">var <span class="ident">double</span> : <a title="nitric.proto.validate.DoubleRules" href="#nitric.proto.validate.DoubleRules">DoubleRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.duration"><code class="name">var <span class="ident">duration</span> : <a title="nitric.proto.validate.DurationRules" href="#nitric.proto.validate.DurationRules">DurationRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.enum"><code class="name">var <span class="ident">enum</span> : <a title="nitric.proto.validate.EnumRules" href="#nitric.proto.validate.EnumRules">EnumRules</a></code></dt>
<dd>
<div class="desc"><p>Complex Field Types</p></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.fixed32"><code class="name">var <span class="ident">fixed32</span> : <a title="nitric.proto.validate.Fixed32Rules" href="#nitric.proto.validate.Fixed32Rules">Fixed32Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.fixed64"><code class="name">var <span class="ident">fixed64</span> : <a title="nitric.proto.validate.Fixed64Rules" href="#nitric.proto.validate.Fixed64Rules">Fixed64Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.float"><code class="name">var <span class="ident">float</span> : <a title="nitric.proto.validate.FloatRules" href="#nitric.proto.validate.FloatRules">FloatRules</a></code></dt>
<dd>
<div class="desc"><p>Scalar Field Types</p></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.int32"><code class="name">var <span class="ident">int32</span> : <a title="nitric.proto.validate.Int32Rules" href="#nitric.proto.validate.Int32Rules">Int32Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.int64"><code class="name">var <span class="ident">int64</span> : <a title="nitric.proto.validate.Int64Rules" href="#nitric.proto.validate.Int64Rules">Int64Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.map"><code class="name">var <span class="ident">map</span> : <a title="nitric.proto.validate.MapRules" href="#nitric.proto.validate.MapRules">MapRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.message"><code class="name">var <span class="ident">message</span> : <a title="nitric.proto.validate.MessageRules" href="#nitric.proto.validate.MessageRules">MessageRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.repeated"><code class="name">var <span class="ident">repeated</span> : <a title="nitric.proto.validate.RepeatedRules" href="#nitric.proto.validate.RepeatedRules">RepeatedRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.sfixed32"><code class="name">var <span class="ident">sfixed32</span> : <a title="nitric.proto.validate.SFixed32Rules" href="#nitric.proto.validate.SFixed32Rules">SFixed32Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.sfixed64"><code class="name">var <span class="ident">sfixed64</span> : <a title="nitric.proto.validate.SFixed64Rules" href="#nitric.proto.validate.SFixed64Rules">SFixed64Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.sint32"><code class="name">var <span class="ident">sint32</span> : <a title="nitric.proto.validate.SInt32Rules" href="#nitric.proto.validate.SInt32Rules">SInt32Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.sint64"><code class="name">var <span class="ident">sint64</span> : <a title="nitric.proto.validate.SInt64Rules" href="#nitric.proto.validate.SInt64Rules">SInt64Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.string"><code class="name">var <span class="ident">string</span> : <a title="nitric.proto.validate.StringRules" href="#nitric.proto.validate.StringRules">StringRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.timestamp"><code class="name">var <span class="ident">timestamp</span> : <a title="nitric.proto.validate.TimestampRules" href="#nitric.proto.validate.TimestampRules">TimestampRules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.uint32"><code class="name">var <span class="ident">uint32</span> : <a title="nitric.proto.validate.UInt32Rules" href="#nitric.proto.validate.UInt32Rules">UInt32Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.proto.validate.FieldRules.uint64"><code class="name">var <span class="ident">uint64</span> : <a title="nitric.proto.validate.UInt64Rules" href="#nitric.proto.validate.UInt64Rules">UInt64Rules</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules"><code class="flex name class">
<span>class <span class="ident">Fixed32Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Fixed32Rules describes the constraints applied to <code>fixed32</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class Fixed32Rules(betterproto.Message):
    &#34;&#34;&#34;Fixed32Rules describes the constraints applied to `fixed32` values&#34;&#34;&#34;

    const: int = betterproto.fixed32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.fixed32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.fixed32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.fixed32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.fixed32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.fixed32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.fixed32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.Fixed32Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed32Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules"><code class="flex name class">
<span>class <span class="ident">Fixed64Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Fixed64Rules describes the constraints applied to <code>fixed64</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class Fixed64Rules(betterproto.Message):
    &#34;&#34;&#34;Fixed64Rules describes the constraints applied to `fixed64` values&#34;&#34;&#34;

    const: int = betterproto.fixed64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.fixed64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.fixed64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.fixed64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.fixed64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.fixed64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.fixed64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.Fixed64Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Fixed64Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.FloatRules"><code class="flex name class">
<span>class <span class="ident">FloatRules</span></span>
<span>(</span><span>const: float = &lt;object object&gt;, lt: float = &lt;object object&gt;, lte: float = &lt;object object&gt;, gt: float = &lt;object object&gt;, gte: float = &lt;object object&gt;, in_: List[float] = &lt;object object&gt;, not_in: List[float] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>FloatRules describes the constraints applied to <code>float</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class FloatRules(betterproto.Message):
    &#34;&#34;&#34;FloatRules describes the constraints applied to `float` values&#34;&#34;&#34;

    const: float = betterproto.float_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: float = betterproto.float_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: float = betterproto.float_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: float = betterproto.float_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: float = betterproto.float_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[float] = betterproto.float_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[float] = betterproto.float_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.FloatRules.const"><code class="name">var <span class="ident">const</span> : float</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.gt"><code class="name">var <span class="ident">gt</span> : float</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.gte"><code class="name">var <span class="ident">gte</span> : float</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.in_"><code class="name">var <span class="ident">in_</span> : List[float]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.lt"><code class="name">var <span class="ident">lt</span> : float</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.lte"><code class="name">var <span class="ident">lte</span> : float</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.FloatRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[float]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.Int32Rules"><code class="flex name class">
<span>class <span class="ident">Int32Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Int32Rules describes the constraints applied to <code>int32</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class Int32Rules(betterproto.Message):
    &#34;&#34;&#34;Int32Rules describes the constraints applied to `int32` values&#34;&#34;&#34;

    const: int = betterproto.int32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.int32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.int32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.int32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.int32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.Int32Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Int32Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.Int64Rules"><code class="flex name class">
<span>class <span class="ident">Int64Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Int64Rules describes the constraints applied to <code>int64</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class Int64Rules(betterproto.Message):
    &#34;&#34;&#34;Int64Rules describes the constraints applied to `int64` values&#34;&#34;&#34;

    const: int = betterproto.int64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.int64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.int64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.int64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.int64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.int64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.int64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.Int64Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.Int64Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.KnownRegex"><code class="flex name class">
<span>class <span class="ident">KnownRegex</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>WellKnownRegex contain some well-known patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KnownRegex(betterproto.Enum):
    &#34;&#34;&#34;WellKnownRegex contain some well-known patterns.&#34;&#34;&#34;

    UNKNOWN = 0
    HTTP_HEADER_NAME = 1
    &#34;&#34;&#34;HTTP header name as defined by RFC 7230.&#34;&#34;&#34;

    HTTP_HEADER_VALUE = 2
    &#34;&#34;&#34;HTTP header value as defined by RFC 7230.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Enum</li>
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.KnownRegex.HTTP_HEADER_NAME"><code class="name">var <span class="ident">HTTP_HEADER_NAME</span></code></dt>
<dd>
<div class="desc"><p>HTTP header name as defined by RFC 7230.</p></div>
</dd>
<dt id="nitric.proto.validate.KnownRegex.HTTP_HEADER_VALUE"><code class="name">var <span class="ident">HTTP_HEADER_VALUE</span></code></dt>
<dd>
<div class="desc"><p>HTTP header value as defined by RFC 7230.</p></div>
</dd>
<dt id="nitric.proto.validate.KnownRegex.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.MapRules"><code class="flex name class">
<span>class <span class="ident">MapRules</span></span>
<span>(</span><span>min_pairs: int = &lt;object object&gt;, max_pairs: int = &lt;object object&gt;, no_sparse: bool = &lt;object object&gt;, keys: <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a> = &lt;object object&gt;, values: <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a> = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>MapRules describe the constraints applied to <code>map</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class MapRules(betterproto.Message):
    &#34;&#34;&#34;MapRules describe the constraints applied to `map` values&#34;&#34;&#34;

    min_pairs: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;
    MinPairs specifies that this field must have the specified number of KVs at
    a minimum
    &#34;&#34;&#34;

    max_pairs: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MaxPairs specifies that this field must have the specified number of KVs at
    a maximum
    &#34;&#34;&#34;

    no_sparse: bool = betterproto.bool_field(3)
    &#34;&#34;&#34;
    NoSparse specifies values in this field cannot be unset. This only applies
    to map&#39;s with message value types.
    &#34;&#34;&#34;

    keys: &#34;FieldRules&#34; = betterproto.message_field(4)
    &#34;&#34;&#34;
    Keys specifies the constraints to be applied to each key in the field.
    &#34;&#34;&#34;

    values: &#34;FieldRules&#34; = betterproto.message_field(5)
    &#34;&#34;&#34;
    Values specifies the constraints to be applied to the value of each key in
    the field. Message values will still have their validations evaluated
    unless skip is specified here.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(6)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.MapRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.MapRules.keys"><code class="name">var <span class="ident">keys</span> : <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a></code></dt>
<dd>
<div class="desc"><p>Keys specifies the constraints to be applied to each key in the field.</p></div>
</dd>
<dt id="nitric.proto.validate.MapRules.max_pairs"><code class="name">var <span class="ident">max_pairs</span> : int</code></dt>
<dd>
<div class="desc"><p>MaxPairs specifies that this field must have the specified number of KVs at
a maximum</p></div>
</dd>
<dt id="nitric.proto.validate.MapRules.min_pairs"><code class="name">var <span class="ident">min_pairs</span> : int</code></dt>
<dd>
<div class="desc"><p>MinPairs specifies that this field must have the specified number of KVs at
a minimum</p></div>
</dd>
<dt id="nitric.proto.validate.MapRules.no_sparse"><code class="name">var <span class="ident">no_sparse</span> : bool</code></dt>
<dd>
<div class="desc"><p>NoSparse specifies values in this field cannot be unset. This only applies
to map's with message value types.</p></div>
</dd>
<dt id="nitric.proto.validate.MapRules.values"><code class="name">var <span class="ident">values</span> : <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a></code></dt>
<dd>
<div class="desc"><p>Values specifies the constraints to be applied to the value of each key in
the field. Message values will still have their validations evaluated
unless skip is specified here.</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.MessageRules"><code class="flex name class">
<span>class <span class="ident">MessageRules</span></span>
<span>(</span><span>skip: bool = &lt;object object&gt;, required: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>MessageRules describe the constraints applied to embedded message values.
For message-type fields, validation is performed recursively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class MessageRules(betterproto.Message):
    &#34;&#34;&#34;
    MessageRules describe the constraints applied to embedded message values.
    For message-type fields, validation is performed recursively.
    &#34;&#34;&#34;

    skip: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;
    Skip specifies that the validation rules of this field should not be
    evaluated
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(2)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.MessageRules.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"><p>Required specifies that this field must be set</p></div>
</dd>
<dt id="nitric.proto.validate.MessageRules.skip"><code class="name">var <span class="ident">skip</span> : bool</code></dt>
<dd>
<div class="desc"><p>Skip specifies that the validation rules of this field should not be
evaluated</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.RepeatedRules"><code class="flex name class">
<span>class <span class="ident">RepeatedRules</span></span>
<span>(</span><span>min_items: int = &lt;object object&gt;, max_items: int = &lt;object object&gt;, unique: bool = &lt;object object&gt;, items: <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a> = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>RepeatedRules describe the constraints applied to <code>repeated</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class RepeatedRules(betterproto.Message):
    &#34;&#34;&#34;RepeatedRules describe the constraints applied to `repeated` values&#34;&#34;&#34;

    min_items: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;
    MinItems specifies that this field must have the specified number of items
    at a minimum
    &#34;&#34;&#34;

    max_items: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MaxItems specifies that this field must have the specified number of items
    at a maximum
    &#34;&#34;&#34;

    unique: bool = betterproto.bool_field(3)
    &#34;&#34;&#34;
    Unique specifies that all elements in this field must be unique. This
    contraint is only applicable to scalar and enum types (messages are not
    supported).
    &#34;&#34;&#34;

    items: &#34;FieldRules&#34; = betterproto.message_field(4)
    &#34;&#34;&#34;
    Items specifies the contraints to be applied to each item in the field.
    Repeated message fields will still execute validation against each item
    unless skip is specified here.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(5)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.RepeatedRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.RepeatedRules.items"><code class="name">var <span class="ident">items</span> : <a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a></code></dt>
<dd>
<div class="desc"><p>Items specifies the contraints to be applied to each item in the field.
Repeated message fields will still execute validation against each item
unless skip is specified here.</p></div>
</dd>
<dt id="nitric.proto.validate.RepeatedRules.max_items"><code class="name">var <span class="ident">max_items</span> : int</code></dt>
<dd>
<div class="desc"><p>MaxItems specifies that this field must have the specified number of items
at a maximum</p></div>
</dd>
<dt id="nitric.proto.validate.RepeatedRules.min_items"><code class="name">var <span class="ident">min_items</span> : int</code></dt>
<dd>
<div class="desc"><p>MinItems specifies that this field must have the specified number of items
at a minimum</p></div>
</dd>
<dt id="nitric.proto.validate.RepeatedRules.unique"><code class="name">var <span class="ident">unique</span> : bool</code></dt>
<dd>
<div class="desc"><p>Unique specifies that all elements in this field must be unique. This
contraint is only applicable to scalar and enum types (messages are not
supported).</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules"><code class="flex name class">
<span>class <span class="ident">SFixed32Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>SFixed32Rules describes the constraints applied to <code>sfixed32</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class SFixed32Rules(betterproto.Message):
    &#34;&#34;&#34;SFixed32Rules describes the constraints applied to `sfixed32` values&#34;&#34;&#34;

    const: int = betterproto.sfixed32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sfixed32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sfixed32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sfixed32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sfixed32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sfixed32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sfixed32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.SFixed32Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed32Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules"><code class="flex name class">
<span>class <span class="ident">SFixed64Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>SFixed64Rules describes the constraints applied to <code>sfixed64</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class SFixed64Rules(betterproto.Message):
    &#34;&#34;&#34;SFixed64Rules describes the constraints applied to `sfixed64` values&#34;&#34;&#34;

    const: int = betterproto.sfixed64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sfixed64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sfixed64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sfixed64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sfixed64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sfixed64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sfixed64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.SFixed64Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SFixed64Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.SInt32Rules"><code class="flex name class">
<span>class <span class="ident">SInt32Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>SInt32Rules describes the constraints applied to <code>sint32</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class SInt32Rules(betterproto.Message):
    &#34;&#34;&#34;SInt32Rules describes the constraints applied to `sint32` values&#34;&#34;&#34;

    const: int = betterproto.sint32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sint32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sint32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sint32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sint32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sint32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sint32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.SInt32Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SInt32Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.SInt64Rules"><code class="flex name class">
<span>class <span class="ident">SInt64Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>SInt64Rules describes the constraints applied to <code>sint64</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class SInt64Rules(betterproto.Message):
    &#34;&#34;&#34;SInt64Rules describes the constraints applied to `sint64` values&#34;&#34;&#34;

    const: int = betterproto.sint64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.sint64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.sint64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.sint64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.sint64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.sint64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.sint64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.SInt64Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.SInt64Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.StringRules"><code class="flex name class">
<span>class <span class="ident">StringRules</span></span>
<span>(</span><span>const: str = &lt;object object&gt;, len: int = &lt;object object&gt;, min_len: int = &lt;object object&gt;, max_len: int = &lt;object object&gt;, len_bytes: int = &lt;object object&gt;, min_bytes: int = &lt;object object&gt;, max_bytes: int = &lt;object object&gt;, pattern: str = &lt;object object&gt;, prefix: str = &lt;object object&gt;, suffix: str = &lt;object object&gt;, contains: str = &lt;object object&gt;, not_contains: str = &lt;object object&gt;, in_: List[str] = &lt;object object&gt;, not_in: List[str] = &lt;object object&gt;, email: bool = &lt;object object&gt;, hostname: bool = &lt;object object&gt;, ip: bool = &lt;object object&gt;, ipv4: bool = &lt;object object&gt;, ipv6: bool = &lt;object object&gt;, uri: bool = &lt;object object&gt;, uri_ref: bool = &lt;object object&gt;, address: bool = &lt;object object&gt;, uuid: bool = &lt;object object&gt;, well_known_regex: <a title="nitric.proto.validate.KnownRegex" href="#nitric.proto.validate.KnownRegex">KnownRegex</a> = &lt;object object&gt;, strict: bool = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>StringRules describe the constraints applied to <code>string</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class StringRules(betterproto.Message):
    &#34;&#34;&#34;StringRules describe the constraints applied to `string` values&#34;&#34;&#34;

    const: str = betterproto.string_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    len: int = betterproto.uint64_field(19)
    &#34;&#34;&#34;
    Len specifies that this field must be the specified number of characters
    (Unicode code points). Note that the number of characters may differ from
    the number of bytes in the string.
    &#34;&#34;&#34;

    min_len: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    MinLen specifies that this field must be the specified number of characters
    (Unicode code points) at a minimum. Note that the number of characters may
    differ from the number of bytes in the string.
    &#34;&#34;&#34;

    max_len: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    MaxLen specifies that this field must be the specified number of characters
    (Unicode code points) at a maximum. Note that the number of characters may
    differ from the number of bytes in the string.
    &#34;&#34;&#34;

    len_bytes: int = betterproto.uint64_field(20)
    &#34;&#34;&#34;
    LenBytes specifies that this field must be the specified number of bytes at
    a minimum
    &#34;&#34;&#34;

    min_bytes: int = betterproto.uint64_field(4)
    &#34;&#34;&#34;
    MinBytes specifies that this field must be the specified number of bytes at
    a minimum
    &#34;&#34;&#34;

    max_bytes: int = betterproto.uint64_field(5)
    &#34;&#34;&#34;
    MaxBytes specifies that this field must be the specified number of bytes at
    a maximum
    &#34;&#34;&#34;

    pattern: str = betterproto.string_field(6)
    &#34;&#34;&#34;
    Pattern specifes that this field must match against the specified regular
    expression (RE2 syntax). The included expression should elide any
    delimiters.
    &#34;&#34;&#34;

    prefix: str = betterproto.string_field(7)
    &#34;&#34;&#34;
    Prefix specifies that this field must have the specified substring at the
    beginning of the string.
    &#34;&#34;&#34;

    suffix: str = betterproto.string_field(8)
    &#34;&#34;&#34;
    Suffix specifies that this field must have the specified substring at the
    end of the string.
    &#34;&#34;&#34;

    contains: str = betterproto.string_field(9)
    &#34;&#34;&#34;
    Contains specifies that this field must have the specified substring
    anywhere in the string.
    &#34;&#34;&#34;

    not_contains: str = betterproto.string_field(23)
    &#34;&#34;&#34;
    NotContains specifies that this field cannot have the specified substring
    anywhere in the string.
    &#34;&#34;&#34;

    in_: List[str] = betterproto.string_field(10)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[str] = betterproto.string_field(11)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    email: bool = betterproto.bool_field(12, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Email specifies that the field must be a valid email address as defined by
    RFC 5322
    &#34;&#34;&#34;

    hostname: bool = betterproto.bool_field(13, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Hostname specifies that the field must be a valid hostname as defined by
    RFC 1034. This constraint does not support internationalized domain names
    (IDNs).
    &#34;&#34;&#34;

    ip: bool = betterproto.bool_field(14, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ip specifies that the field must be a valid IP (v4 or v6) address. Valid
    IPv6 addresses should not include surrounding square brackets.
    &#34;&#34;&#34;

    ipv4: bool = betterproto.bool_field(15, group=&#34;well_known&#34;)
    &#34;&#34;&#34;Ipv4 specifies that the field must be a valid IPv4 address.&#34;&#34;&#34;

    ipv6: bool = betterproto.bool_field(16, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Ipv6 specifies that the field must be a valid IPv6 address. Valid IPv6
    addresses should not include surrounding square brackets.
    &#34;&#34;&#34;

    uri: bool = betterproto.bool_field(17, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Uri specifies that the field must be a valid, absolute URI as defined by
    RFC 3986
    &#34;&#34;&#34;

    uri_ref: bool = betterproto.bool_field(18, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    UriRef specifies that the field must be a valid URI as defined by RFC 3986
    and may be relative or absolute.
    &#34;&#34;&#34;

    address: bool = betterproto.bool_field(21, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Address specifies that the field must be either a valid hostname as defined
    by RFC 1034 (which does not support internationalized domain names or
    IDNs), or it can be a valid IP (v4 or v6).
    &#34;&#34;&#34;

    uuid: bool = betterproto.bool_field(22, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    Uuid specifies that the field must be a valid UUID as defined by RFC 4122
    &#34;&#34;&#34;

    well_known_regex: &#34;KnownRegex&#34; = betterproto.enum_field(24, group=&#34;well_known&#34;)
    &#34;&#34;&#34;
    WellKnownRegex specifies a common well known pattern defined as a regex.
    &#34;&#34;&#34;

    strict: bool = betterproto.bool_field(25)
    &#34;&#34;&#34;
    This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
    strict header validation. By default, this is true, and HTTP header
    validations are RFC-compliant. Setting to false will enable a looser
    validations that only disallows \r\n\0 characters, which can be used to
    bypass header matching rules.
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(26)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.StringRules.address"><code class="name">var <span class="ident">address</span> : bool</code></dt>
<dd>
<div class="desc"><p>Address specifies that the field must be either a valid hostname as defined
by RFC 1034 (which does not support internationalized domain names or
IDNs), or it can be a valid IP (v4 or v6).</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.const"><code class="name">var <span class="ident">const</span> : str</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.contains"><code class="name">var <span class="ident">contains</span> : str</code></dt>
<dd>
<div class="desc"><p>Contains specifies that this field must have the specified substring
anywhere in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.email"><code class="name">var <span class="ident">email</span> : bool</code></dt>
<dd>
<div class="desc"><p>Email specifies that the field must be a valid email address as defined by
RFC 5322</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.hostname"><code class="name">var <span class="ident">hostname</span> : bool</code></dt>
<dd>
<div class="desc"><p>Hostname specifies that the field must be a valid hostname as defined by
RFC 1034. This constraint does not support internationalized domain names
(IDNs).</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.in_"><code class="name">var <span class="ident">in_</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.ip"><code class="name">var <span class="ident">ip</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ip specifies that the field must be a valid IP (v4 or v6) address. Valid
IPv6 addresses should not include surrounding square brackets.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.ipv4"><code class="name">var <span class="ident">ipv4</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ipv4 specifies that the field must be a valid IPv4 address.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.ipv6"><code class="name">var <span class="ident">ipv6</span> : bool</code></dt>
<dd>
<div class="desc"><p>Ipv6 specifies that the field must be a valid IPv6 address. Valid IPv6
addresses should not include surrounding square brackets.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.len"><code class="name">var <span class="ident">len</span> : int</code></dt>
<dd>
<div class="desc"><p>Len specifies that this field must be the specified number of characters
(Unicode code points). Note that the number of characters may differ from
the number of bytes in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.len_bytes"><code class="name">var <span class="ident">len_bytes</span> : int</code></dt>
<dd>
<div class="desc"><p>LenBytes specifies that this field must be the specified number of bytes at
a minimum</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.max_bytes"><code class="name">var <span class="ident">max_bytes</span> : int</code></dt>
<dd>
<div class="desc"><p>MaxBytes specifies that this field must be the specified number of bytes at
a maximum</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.max_len"><code class="name">var <span class="ident">max_len</span> : int</code></dt>
<dd>
<div class="desc"><p>MaxLen specifies that this field must be the specified number of characters
(Unicode code points) at a maximum. Note that the number of characters may
differ from the number of bytes in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.min_bytes"><code class="name">var <span class="ident">min_bytes</span> : int</code></dt>
<dd>
<div class="desc"><p>MinBytes specifies that this field must be the specified number of bytes at
a minimum</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.min_len"><code class="name">var <span class="ident">min_len</span> : int</code></dt>
<dd>
<div class="desc"><p>MinLen specifies that this field must be the specified number of characters
(Unicode code points) at a minimum. Note that the number of characters may
differ from the number of bytes in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.not_contains"><code class="name">var <span class="ident">not_contains</span> : str</code></dt>
<dd>
<div class="desc"><p>NotContains specifies that this field cannot have the specified substring
anywhere in the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.not_in"><code class="name">var <span class="ident">not_in</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.pattern"><code class="name">var <span class="ident">pattern</span> : str</code></dt>
<dd>
<div class="desc"><p>Pattern specifes that this field must match against the specified regular
expression (RE2 syntax). The included expression should elide any
delimiters.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.prefix"><code class="name">var <span class="ident">prefix</span> : str</code></dt>
<dd>
<div class="desc"><p>Prefix specifies that this field must have the specified substring at the
beginning of the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.strict"><code class="name">var <span class="ident">strict</span> : bool</code></dt>
<dd>
<div class="desc"><p>This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
strict header validation. By default, this is true, and HTTP header
validations are RFC-compliant. Setting to false will enable a looser
validations that only disallows
  characters, which can be used to
bypass header matching rules.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.suffix"><code class="name">var <span class="ident">suffix</span> : str</code></dt>
<dd>
<div class="desc"><p>Suffix specifies that this field must have the specified substring at the
end of the string.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.uri"><code class="name">var <span class="ident">uri</span> : bool</code></dt>
<dd>
<div class="desc"><p>Uri specifies that the field must be a valid, absolute URI as defined by
RFC 3986</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.uri_ref"><code class="name">var <span class="ident">uri_ref</span> : bool</code></dt>
<dd>
<div class="desc"><p>UriRef specifies that the field must be a valid URI as defined by RFC 3986
and may be relative or absolute.</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.uuid"><code class="name">var <span class="ident">uuid</span> : bool</code></dt>
<dd>
<div class="desc"><p>Uuid specifies that the field must be a valid UUID as defined by RFC 4122</p></div>
</dd>
<dt id="nitric.proto.validate.StringRules.well_known_regex"><code class="name">var <span class="ident">well_known_regex</span> : <a title="nitric.proto.validate.KnownRegex" href="#nitric.proto.validate.KnownRegex">KnownRegex</a></code></dt>
<dd>
<div class="desc"><p>WellKnownRegex specifies a common well known pattern defined as a regex.</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.TimestampRules"><code class="flex name class">
<span>class <span class="ident">TimestampRules</span></span>
<span>(</span><span>required: bool = &lt;object object&gt;, const: datetime.datetime = &lt;object object&gt;, lt: datetime.datetime = &lt;object object&gt;, lte: datetime.datetime = &lt;object object&gt;, gt: datetime.datetime = &lt;object object&gt;, gte: datetime.datetime = &lt;object object&gt;, lt_now: bool = &lt;object object&gt;, gt_now: bool = &lt;object object&gt;, within: datetime.timedelta = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>TimestampRules describe the constraints applied exclusively to the
<code>google.protobuf.Timestamp</code> well-known type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class TimestampRules(betterproto.Message):
    &#34;&#34;&#34;
    TimestampRules describe the constraints applied exclusively to the
    `google.protobuf.Timestamp` well-known type
    &#34;&#34;&#34;

    required: bool = betterproto.bool_field(1)
    &#34;&#34;&#34;Required specifies that this field must be set&#34;&#34;&#34;

    const: datetime = betterproto.message_field(2)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: datetime = betterproto.message_field(3)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: datetime = betterproto.message_field(4)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than the specified value,
    inclusive
    &#34;&#34;&#34;

    gt: datetime = betterproto.message_field(5)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive
    &#34;&#34;&#34;

    gte: datetime = betterproto.message_field(6)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than the specified value,
    inclusive
    &#34;&#34;&#34;

    lt_now: bool = betterproto.bool_field(7)
    &#34;&#34;&#34;
    LtNow specifies that this must be less than the current time. LtNow can
    only be used with the Within rule.
    &#34;&#34;&#34;

    gt_now: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    GtNow specifies that this must be greater than the current time. GtNow can
    only be used with the Within rule.
    &#34;&#34;&#34;

    within: timedelta = betterproto.message_field(9)
    &#34;&#34;&#34;
    Within specifies that this field must be within this duration of the
    current time. This constraint can be used alone or with the LtNow and GtNow
    rules.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.TimestampRules.const"><code class="name">var <span class="ident">const</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.gt"><code class="name">var <span class="ident">gt</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.gt_now"><code class="name">var <span class="ident">gt_now</span> : bool</code></dt>
<dd>
<div class="desc"><p>GtNow specifies that this must be greater than the current time. GtNow can
only be used with the Within rule.</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.gte"><code class="name">var <span class="ident">gte</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than the specified value,
inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.lt"><code class="name">var <span class="ident">lt</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.lt_now"><code class="name">var <span class="ident">lt_now</span> : bool</code></dt>
<dd>
<div class="desc"><p>LtNow specifies that this must be less than the current time. LtNow can
only be used with the Within rule.</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.lte"><code class="name">var <span class="ident">lte</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than the specified value,
inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"><p>Required specifies that this field must be set</p></div>
</dd>
<dt id="nitric.proto.validate.TimestampRules.within"><code class="name">var <span class="ident">within</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"><p>Within specifies that this field must be within this duration of the
current time. This constraint can be used alone or with the LtNow and GtNow
rules.</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.UInt32Rules"><code class="flex name class">
<span>class <span class="ident">UInt32Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>UInt32Rules describes the constraints applied to <code>uint32</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class UInt32Rules(betterproto.Message):
    &#34;&#34;&#34;UInt32Rules describes the constraints applied to `uint32` values&#34;&#34;&#34;

    const: int = betterproto.uint32_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.uint32_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.uint32_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.uint32_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.uint32_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.uint32_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.uint32_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.UInt32Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.UInt32Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
<dt id="nitric.proto.validate.UInt64Rules"><code class="flex name class">
<span>class <span class="ident">UInt64Rules</span></span>
<span>(</span><span>const: int = &lt;object object&gt;, lt: int = &lt;object object&gt;, lte: int = &lt;object object&gt;, gt: int = &lt;object object&gt;, gte: int = &lt;object object&gt;, in_: List[int] = &lt;object object&gt;, not_in: List[int] = &lt;object object&gt;, ignore_empty: bool = &lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>UInt64Rules describes the constraints applied to <code>uint64</code> values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, repr=False)
class UInt64Rules(betterproto.Message):
    &#34;&#34;&#34;UInt64Rules describes the constraints applied to `uint64` values&#34;&#34;&#34;

    const: int = betterproto.uint64_field(1)
    &#34;&#34;&#34;Const specifies that this field must be exactly the specified value&#34;&#34;&#34;

    lt: int = betterproto.uint64_field(2)
    &#34;&#34;&#34;
    Lt specifies that this field must be less than the specified value,
    exclusive
    &#34;&#34;&#34;

    lte: int = betterproto.uint64_field(3)
    &#34;&#34;&#34;
    Lte specifies that this field must be less than or equal to the specified
    value, inclusive
    &#34;&#34;&#34;

    gt: int = betterproto.uint64_field(4)
    &#34;&#34;&#34;
    Gt specifies that this field must be greater than the specified value,
    exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    range is reversed.
    &#34;&#34;&#34;

    gte: int = betterproto.uint64_field(5)
    &#34;&#34;&#34;
    Gte specifies that this field must be greater than or equal to the
    specified value, inclusive. If the value of Gte is larger than a specified
    Lt or Lte, the range is reversed.
    &#34;&#34;&#34;

    in_: List[int] = betterproto.uint64_field(6)
    &#34;&#34;&#34;
    In specifies that this field must be equal to one of the specified values
    &#34;&#34;&#34;

    not_in: List[int] = betterproto.uint64_field(7)
    &#34;&#34;&#34;
    NotIn specifies that this field cannot be equal to one of the specified
    values
    &#34;&#34;&#34;

    ignore_empty: bool = betterproto.bool_field(8)
    &#34;&#34;&#34;
    IgnoreEmpty specifies that the validation rules of this field should be
    evaluated only if the field is not empty
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>betterproto.Message</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.proto.validate.UInt64Rules.const"><code class="name">var <span class="ident">const</span> : int</code></dt>
<dd>
<div class="desc"><p>Const specifies that this field must be exactly the specified value</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.gt"><code class="name">var <span class="ident">gt</span> : int</code></dt>
<dd>
<div class="desc"><p>Gt specifies that this field must be greater than the specified value,
exclusive. If the value of Gt is larger than a specified Lt or Lte, the
range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.gte"><code class="name">var <span class="ident">gte</span> : int</code></dt>
<dd>
<div class="desc"><p>Gte specifies that this field must be greater than or equal to the
specified value, inclusive. If the value of Gte is larger than a specified
Lt or Lte, the range is reversed.</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.ignore_empty"><code class="name">var <span class="ident">ignore_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>IgnoreEmpty specifies that the validation rules of this field should be
evaluated only if the field is not empty</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.in_"><code class="name">var <span class="ident">in_</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>In specifies that this field must be equal to one of the specified values</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.lt"><code class="name">var <span class="ident">lt</span> : int</code></dt>
<dd>
<div class="desc"><p>Lt specifies that this field must be less than the specified value,
exclusive</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.lte"><code class="name">var <span class="ident">lte</span> : int</code></dt>
<dd>
<div class="desc"><p>Lte specifies that this field must be less than or equal to the specified
value, inclusive</p></div>
</dd>
<dt id="nitric.proto.validate.UInt64Rules.not_in"><code class="name">var <span class="ident">not_in</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>NotIn specifies that this field cannot be equal to one of the specified
values</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nitric.proto" href="../index.html">nitric.proto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nitric.proto.validate.AnyRules" href="#nitric.proto.validate.AnyRules">AnyRules</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.AnyRules.in_" href="#nitric.proto.validate.AnyRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.AnyRules.not_in" href="#nitric.proto.validate.AnyRules.not_in">not_in</a></code></li>
<li><code><a title="nitric.proto.validate.AnyRules.required" href="#nitric.proto.validate.AnyRules.required">required</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.BoolRules" href="#nitric.proto.validate.BoolRules">BoolRules</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.BoolRules.const" href="#nitric.proto.validate.BoolRules.const">const</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.BytesRules" href="#nitric.proto.validate.BytesRules">BytesRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.BytesRules.const" href="#nitric.proto.validate.BytesRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.contains" href="#nitric.proto.validate.BytesRules.contains">contains</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.ignore_empty" href="#nitric.proto.validate.BytesRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.in_" href="#nitric.proto.validate.BytesRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.ip" href="#nitric.proto.validate.BytesRules.ip">ip</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.ipv4" href="#nitric.proto.validate.BytesRules.ipv4">ipv4</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.ipv6" href="#nitric.proto.validate.BytesRules.ipv6">ipv6</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.len" href="#nitric.proto.validate.BytesRules.len">len</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.max_len" href="#nitric.proto.validate.BytesRules.max_len">max_len</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.min_len" href="#nitric.proto.validate.BytesRules.min_len">min_len</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.not_in" href="#nitric.proto.validate.BytesRules.not_in">not_in</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.pattern" href="#nitric.proto.validate.BytesRules.pattern">pattern</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.prefix" href="#nitric.proto.validate.BytesRules.prefix">prefix</a></code></li>
<li><code><a title="nitric.proto.validate.BytesRules.suffix" href="#nitric.proto.validate.BytesRules.suffix">suffix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.DoubleRules" href="#nitric.proto.validate.DoubleRules">DoubleRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.DoubleRules.const" href="#nitric.proto.validate.DoubleRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.gt" href="#nitric.proto.validate.DoubleRules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.gte" href="#nitric.proto.validate.DoubleRules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.ignore_empty" href="#nitric.proto.validate.DoubleRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.in_" href="#nitric.proto.validate.DoubleRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.lt" href="#nitric.proto.validate.DoubleRules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.lte" href="#nitric.proto.validate.DoubleRules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.DoubleRules.not_in" href="#nitric.proto.validate.DoubleRules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.DurationRules" href="#nitric.proto.validate.DurationRules">DurationRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.DurationRules.const" href="#nitric.proto.validate.DurationRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.gt" href="#nitric.proto.validate.DurationRules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.gte" href="#nitric.proto.validate.DurationRules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.in_" href="#nitric.proto.validate.DurationRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.lt" href="#nitric.proto.validate.DurationRules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.lte" href="#nitric.proto.validate.DurationRules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.not_in" href="#nitric.proto.validate.DurationRules.not_in">not_in</a></code></li>
<li><code><a title="nitric.proto.validate.DurationRules.required" href="#nitric.proto.validate.DurationRules.required">required</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.EnumRules" href="#nitric.proto.validate.EnumRules">EnumRules</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.EnumRules.const" href="#nitric.proto.validate.EnumRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.EnumRules.defined_only" href="#nitric.proto.validate.EnumRules.defined_only">defined_only</a></code></li>
<li><code><a title="nitric.proto.validate.EnumRules.in_" href="#nitric.proto.validate.EnumRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.EnumRules.not_in" href="#nitric.proto.validate.EnumRules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.FieldRules" href="#nitric.proto.validate.FieldRules">FieldRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.FieldRules.any" href="#nitric.proto.validate.FieldRules.any">any</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.bool" href="#nitric.proto.validate.FieldRules.bool">bool</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.bytes" href="#nitric.proto.validate.FieldRules.bytes">bytes</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.double" href="#nitric.proto.validate.FieldRules.double">double</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.duration" href="#nitric.proto.validate.FieldRules.duration">duration</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.enum" href="#nitric.proto.validate.FieldRules.enum">enum</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.fixed32" href="#nitric.proto.validate.FieldRules.fixed32">fixed32</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.fixed64" href="#nitric.proto.validate.FieldRules.fixed64">fixed64</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.float" href="#nitric.proto.validate.FieldRules.float">float</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.int32" href="#nitric.proto.validate.FieldRules.int32">int32</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.int64" href="#nitric.proto.validate.FieldRules.int64">int64</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.map" href="#nitric.proto.validate.FieldRules.map">map</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.message" href="#nitric.proto.validate.FieldRules.message">message</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.repeated" href="#nitric.proto.validate.FieldRules.repeated">repeated</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.sfixed32" href="#nitric.proto.validate.FieldRules.sfixed32">sfixed32</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.sfixed64" href="#nitric.proto.validate.FieldRules.sfixed64">sfixed64</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.sint32" href="#nitric.proto.validate.FieldRules.sint32">sint32</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.sint64" href="#nitric.proto.validate.FieldRules.sint64">sint64</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.string" href="#nitric.proto.validate.FieldRules.string">string</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.timestamp" href="#nitric.proto.validate.FieldRules.timestamp">timestamp</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.uint32" href="#nitric.proto.validate.FieldRules.uint32">uint32</a></code></li>
<li><code><a title="nitric.proto.validate.FieldRules.uint64" href="#nitric.proto.validate.FieldRules.uint64">uint64</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.Fixed32Rules" href="#nitric.proto.validate.Fixed32Rules">Fixed32Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.Fixed32Rules.const" href="#nitric.proto.validate.Fixed32Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.gt" href="#nitric.proto.validate.Fixed32Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.gte" href="#nitric.proto.validate.Fixed32Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.ignore_empty" href="#nitric.proto.validate.Fixed32Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.in_" href="#nitric.proto.validate.Fixed32Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.lt" href="#nitric.proto.validate.Fixed32Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.lte" href="#nitric.proto.validate.Fixed32Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed32Rules.not_in" href="#nitric.proto.validate.Fixed32Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.Fixed64Rules" href="#nitric.proto.validate.Fixed64Rules">Fixed64Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.Fixed64Rules.const" href="#nitric.proto.validate.Fixed64Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.gt" href="#nitric.proto.validate.Fixed64Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.gte" href="#nitric.proto.validate.Fixed64Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.ignore_empty" href="#nitric.proto.validate.Fixed64Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.in_" href="#nitric.proto.validate.Fixed64Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.lt" href="#nitric.proto.validate.Fixed64Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.lte" href="#nitric.proto.validate.Fixed64Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.Fixed64Rules.not_in" href="#nitric.proto.validate.Fixed64Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.FloatRules" href="#nitric.proto.validate.FloatRules">FloatRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.FloatRules.const" href="#nitric.proto.validate.FloatRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.gt" href="#nitric.proto.validate.FloatRules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.gte" href="#nitric.proto.validate.FloatRules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.ignore_empty" href="#nitric.proto.validate.FloatRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.in_" href="#nitric.proto.validate.FloatRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.lt" href="#nitric.proto.validate.FloatRules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.lte" href="#nitric.proto.validate.FloatRules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.FloatRules.not_in" href="#nitric.proto.validate.FloatRules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.Int32Rules" href="#nitric.proto.validate.Int32Rules">Int32Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.Int32Rules.const" href="#nitric.proto.validate.Int32Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.gt" href="#nitric.proto.validate.Int32Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.gte" href="#nitric.proto.validate.Int32Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.ignore_empty" href="#nitric.proto.validate.Int32Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.in_" href="#nitric.proto.validate.Int32Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.lt" href="#nitric.proto.validate.Int32Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.lte" href="#nitric.proto.validate.Int32Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.Int32Rules.not_in" href="#nitric.proto.validate.Int32Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.Int64Rules" href="#nitric.proto.validate.Int64Rules">Int64Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.Int64Rules.const" href="#nitric.proto.validate.Int64Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.gt" href="#nitric.proto.validate.Int64Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.gte" href="#nitric.proto.validate.Int64Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.ignore_empty" href="#nitric.proto.validate.Int64Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.in_" href="#nitric.proto.validate.Int64Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.lt" href="#nitric.proto.validate.Int64Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.lte" href="#nitric.proto.validate.Int64Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.Int64Rules.not_in" href="#nitric.proto.validate.Int64Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.KnownRegex" href="#nitric.proto.validate.KnownRegex">KnownRegex</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.KnownRegex.HTTP_HEADER_NAME" href="#nitric.proto.validate.KnownRegex.HTTP_HEADER_NAME">HTTP_HEADER_NAME</a></code></li>
<li><code><a title="nitric.proto.validate.KnownRegex.HTTP_HEADER_VALUE" href="#nitric.proto.validate.KnownRegex.HTTP_HEADER_VALUE">HTTP_HEADER_VALUE</a></code></li>
<li><code><a title="nitric.proto.validate.KnownRegex.UNKNOWN" href="#nitric.proto.validate.KnownRegex.UNKNOWN">UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.MapRules" href="#nitric.proto.validate.MapRules">MapRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.MapRules.ignore_empty" href="#nitric.proto.validate.MapRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.MapRules.keys" href="#nitric.proto.validate.MapRules.keys">keys</a></code></li>
<li><code><a title="nitric.proto.validate.MapRules.max_pairs" href="#nitric.proto.validate.MapRules.max_pairs">max_pairs</a></code></li>
<li><code><a title="nitric.proto.validate.MapRules.min_pairs" href="#nitric.proto.validate.MapRules.min_pairs">min_pairs</a></code></li>
<li><code><a title="nitric.proto.validate.MapRules.no_sparse" href="#nitric.proto.validate.MapRules.no_sparse">no_sparse</a></code></li>
<li><code><a title="nitric.proto.validate.MapRules.values" href="#nitric.proto.validate.MapRules.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.MessageRules" href="#nitric.proto.validate.MessageRules">MessageRules</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.MessageRules.required" href="#nitric.proto.validate.MessageRules.required">required</a></code></li>
<li><code><a title="nitric.proto.validate.MessageRules.skip" href="#nitric.proto.validate.MessageRules.skip">skip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.RepeatedRules" href="#nitric.proto.validate.RepeatedRules">RepeatedRules</a></code></h4>
<ul class="">
<li><code><a title="nitric.proto.validate.RepeatedRules.ignore_empty" href="#nitric.proto.validate.RepeatedRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.RepeatedRules.items" href="#nitric.proto.validate.RepeatedRules.items">items</a></code></li>
<li><code><a title="nitric.proto.validate.RepeatedRules.max_items" href="#nitric.proto.validate.RepeatedRules.max_items">max_items</a></code></li>
<li><code><a title="nitric.proto.validate.RepeatedRules.min_items" href="#nitric.proto.validate.RepeatedRules.min_items">min_items</a></code></li>
<li><code><a title="nitric.proto.validate.RepeatedRules.unique" href="#nitric.proto.validate.RepeatedRules.unique">unique</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.SFixed32Rules" href="#nitric.proto.validate.SFixed32Rules">SFixed32Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.SFixed32Rules.const" href="#nitric.proto.validate.SFixed32Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.gt" href="#nitric.proto.validate.SFixed32Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.gte" href="#nitric.proto.validate.SFixed32Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.ignore_empty" href="#nitric.proto.validate.SFixed32Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.in_" href="#nitric.proto.validate.SFixed32Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.lt" href="#nitric.proto.validate.SFixed32Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.lte" href="#nitric.proto.validate.SFixed32Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed32Rules.not_in" href="#nitric.proto.validate.SFixed32Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.SFixed64Rules" href="#nitric.proto.validate.SFixed64Rules">SFixed64Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.SFixed64Rules.const" href="#nitric.proto.validate.SFixed64Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.gt" href="#nitric.proto.validate.SFixed64Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.gte" href="#nitric.proto.validate.SFixed64Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.ignore_empty" href="#nitric.proto.validate.SFixed64Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.in_" href="#nitric.proto.validate.SFixed64Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.lt" href="#nitric.proto.validate.SFixed64Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.lte" href="#nitric.proto.validate.SFixed64Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.SFixed64Rules.not_in" href="#nitric.proto.validate.SFixed64Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.SInt32Rules" href="#nitric.proto.validate.SInt32Rules">SInt32Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.SInt32Rules.const" href="#nitric.proto.validate.SInt32Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.gt" href="#nitric.proto.validate.SInt32Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.gte" href="#nitric.proto.validate.SInt32Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.ignore_empty" href="#nitric.proto.validate.SInt32Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.in_" href="#nitric.proto.validate.SInt32Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.lt" href="#nitric.proto.validate.SInt32Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.lte" href="#nitric.proto.validate.SInt32Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.SInt32Rules.not_in" href="#nitric.proto.validate.SInt32Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.SInt64Rules" href="#nitric.proto.validate.SInt64Rules">SInt64Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.SInt64Rules.const" href="#nitric.proto.validate.SInt64Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.gt" href="#nitric.proto.validate.SInt64Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.gte" href="#nitric.proto.validate.SInt64Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.ignore_empty" href="#nitric.proto.validate.SInt64Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.in_" href="#nitric.proto.validate.SInt64Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.lt" href="#nitric.proto.validate.SInt64Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.lte" href="#nitric.proto.validate.SInt64Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.SInt64Rules.not_in" href="#nitric.proto.validate.SInt64Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.StringRules" href="#nitric.proto.validate.StringRules">StringRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.StringRules.address" href="#nitric.proto.validate.StringRules.address">address</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.const" href="#nitric.proto.validate.StringRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.contains" href="#nitric.proto.validate.StringRules.contains">contains</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.email" href="#nitric.proto.validate.StringRules.email">email</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.hostname" href="#nitric.proto.validate.StringRules.hostname">hostname</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.ignore_empty" href="#nitric.proto.validate.StringRules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.in_" href="#nitric.proto.validate.StringRules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.ip" href="#nitric.proto.validate.StringRules.ip">ip</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.ipv4" href="#nitric.proto.validate.StringRules.ipv4">ipv4</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.ipv6" href="#nitric.proto.validate.StringRules.ipv6">ipv6</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.len" href="#nitric.proto.validate.StringRules.len">len</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.len_bytes" href="#nitric.proto.validate.StringRules.len_bytes">len_bytes</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.max_bytes" href="#nitric.proto.validate.StringRules.max_bytes">max_bytes</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.max_len" href="#nitric.proto.validate.StringRules.max_len">max_len</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.min_bytes" href="#nitric.proto.validate.StringRules.min_bytes">min_bytes</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.min_len" href="#nitric.proto.validate.StringRules.min_len">min_len</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.not_contains" href="#nitric.proto.validate.StringRules.not_contains">not_contains</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.not_in" href="#nitric.proto.validate.StringRules.not_in">not_in</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.pattern" href="#nitric.proto.validate.StringRules.pattern">pattern</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.prefix" href="#nitric.proto.validate.StringRules.prefix">prefix</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.strict" href="#nitric.proto.validate.StringRules.strict">strict</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.suffix" href="#nitric.proto.validate.StringRules.suffix">suffix</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.uri" href="#nitric.proto.validate.StringRules.uri">uri</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.uri_ref" href="#nitric.proto.validate.StringRules.uri_ref">uri_ref</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.uuid" href="#nitric.proto.validate.StringRules.uuid">uuid</a></code></li>
<li><code><a title="nitric.proto.validate.StringRules.well_known_regex" href="#nitric.proto.validate.StringRules.well_known_regex">well_known_regex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.TimestampRules" href="#nitric.proto.validate.TimestampRules">TimestampRules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.TimestampRules.const" href="#nitric.proto.validate.TimestampRules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.gt" href="#nitric.proto.validate.TimestampRules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.gt_now" href="#nitric.proto.validate.TimestampRules.gt_now">gt_now</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.gte" href="#nitric.proto.validate.TimestampRules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.lt" href="#nitric.proto.validate.TimestampRules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.lt_now" href="#nitric.proto.validate.TimestampRules.lt_now">lt_now</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.lte" href="#nitric.proto.validate.TimestampRules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.required" href="#nitric.proto.validate.TimestampRules.required">required</a></code></li>
<li><code><a title="nitric.proto.validate.TimestampRules.within" href="#nitric.proto.validate.TimestampRules.within">within</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.UInt32Rules" href="#nitric.proto.validate.UInt32Rules">UInt32Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.UInt32Rules.const" href="#nitric.proto.validate.UInt32Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.gt" href="#nitric.proto.validate.UInt32Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.gte" href="#nitric.proto.validate.UInt32Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.ignore_empty" href="#nitric.proto.validate.UInt32Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.in_" href="#nitric.proto.validate.UInt32Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.lt" href="#nitric.proto.validate.UInt32Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.lte" href="#nitric.proto.validate.UInt32Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.UInt32Rules.not_in" href="#nitric.proto.validate.UInt32Rules.not_in">not_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.proto.validate.UInt64Rules" href="#nitric.proto.validate.UInt64Rules">UInt64Rules</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.proto.validate.UInt64Rules.const" href="#nitric.proto.validate.UInt64Rules.const">const</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.gt" href="#nitric.proto.validate.UInt64Rules.gt">gt</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.gte" href="#nitric.proto.validate.UInt64Rules.gte">gte</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.ignore_empty" href="#nitric.proto.validate.UInt64Rules.ignore_empty">ignore_empty</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.in_" href="#nitric.proto.validate.UInt64Rules.in_">in_</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.lt" href="#nitric.proto.validate.UInt64Rules.lt">lt</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.lte" href="#nitric.proto.validate.UInt64Rules.lte">lte</a></code></li>
<li><code><a title="nitric.proto.validate.UInt64Rules.not_in" href="#nitric.proto.validate.UInt64Rules.not_in">not_in</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>