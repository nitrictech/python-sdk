<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nitric.faas API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nitric.faas</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2021 Nitric Technologies Pty Ltd.
#
# This file is part of Nitric Python 3 SDK.
# See https://github.com/nitrictech/python-sdk for further info.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from __future__ import annotations
from enum import Enum

import functools
import json
import traceback
from typing import Dict, Union, List, TypeVar, Callable, Coroutine, Any, Optional
from opentelemetry import context, propagate

import betterproto
from betterproto.grpc.util.async_channel import AsyncChannel
from nitric.utils import new_default_channel
from nitric.proto.nitric.faas.v1 import (
    FaasServiceStub,
    InitRequest,
    ClientMessage,
    TriggerRequest,
    TriggerResponse,
    HeaderValue,
    HttpResponseContext,
    TopicResponseContext,
    ScheduleWorker,
    ApiWorker,
    SubscriptionWorker,
    ScheduleRate,
)
import grpclib
import asyncio
from abc import ABC

Record = Dict[str, Union[str, List[str]]]
PROPAGATOR = propagate.get_global_textmap()


class HttpMethod(Enum):
    &#34;&#34;&#34;Valid query expression operators.&#34;&#34;&#34;

    GET = &#34;GET&#34;
    POST = &#34;POST&#34;
    PUT = &#34;PUT&#34;
    DELETE = &#34;DELETE&#34;
    PATCH = &#34;PATCH&#34;
    OPTIONS = &#34;OPTIONS&#34;

    def __str__(self):
        return str(self.value)


class Request(ABC):
    &#34;&#34;&#34;Represents an abstract trigger request.&#34;&#34;&#34;

    def __init__(self, data: bytes):
        &#34;&#34;&#34;Construct a new Request.&#34;&#34;&#34;
        self.data = data


class Response(ABC):
    &#34;&#34;&#34;Represents an abstract trigger response.&#34;&#34;&#34;

    pass


class TriggerContext(ABC):
    &#34;&#34;&#34;Represents an abstract request/response context for any trigger.&#34;&#34;&#34;

    def http(self) -&gt; Union[HttpContext, None]:
        &#34;&#34;&#34;Return this context as an HttpContext if it is one, otherwise returns None.&#34;&#34;&#34;
        return None

    def event(self) -&gt; Union[EventContext, None]:
        &#34;&#34;&#34;Return this context as an EventContext if it is one, otherwise returns None.&#34;&#34;&#34;
        return None


def _ctx_from_grpc_trigger_request(trigger_request: TriggerRequest):
    &#34;&#34;&#34;Return a TriggerContext from a TriggerRequest.&#34;&#34;&#34;
    context_type, context = betterproto.which_one_of(trigger_request, &#34;context&#34;)
    if context_type == &#34;http&#34;:
        return HttpContext.from_grpc_trigger_request(trigger_request)
    elif context_type == &#34;topic&#34;:
        return EventContext.from_grpc_trigger_request(trigger_request)
    else:
        print(f&#34;Trigger with unknown context received, context type: {context_type}&#34;)
        raise Exception(f&#34;Unknown trigger context, type: {context_type}&#34;)


def _grpc_response_from_ctx(ctx: TriggerContext) -&gt; TriggerResponse:
    &#34;&#34;&#34;
    Create a GRPC TriggerResponse from a TriggerContext.

    The ctx is used to determine the appropriate TriggerResponse content,
    the ctx.res is then used to construct the response.
    &#34;&#34;&#34;
    if ctx.http():
        ctx = ctx.http()
        headers = {k: HeaderValue(value=v) for (k, v) in ctx.res.headers.items()}
        headers_old = {k: v[0] for (k, v) in ctx.res.headers.items()}
        data = ctx.res.body if ctx.res.body else bytes()

        return TriggerResponse(
            data=data,
            http=HttpResponseContext(status=ctx.res.status, headers=headers, headers_old=headers_old),
        )
    elif ctx.event():
        ctx = ctx.event()
        return TriggerResponse(
            topic=TopicResponseContext(
                success=ctx.res.success,
            ),
        )
    else:
        raise Exception(&#34;Unknown Trigger Context type, unable to return valid response&#34;)


# ====== HTTP ======


class HttpRequest(Request):
    &#34;&#34;&#34;Represents a translated Http Request forwarded from the Nitric Membrane.&#34;&#34;&#34;

    def __init__(
        self,
        data: bytes,
        method: str,
        path: str,
        params: Dict[str, str],
        query: Record,
        headers: Record,
        trace_context: Dict[str, str],
    ):
        &#34;&#34;&#34;Construct a new HttpRequest.&#34;&#34;&#34;
        super().__init__(data)
        self.method = method
        self.path = path
        self.params = params
        self.query = query
        self.headers = headers
        self.trace_context = trace_context

    @property
    def json(self) -&gt; Optional[Any]:
        &#34;&#34;&#34;Get the body of the request as JSON, returns None if request body is not JSON.&#34;&#34;&#34;
        try:
            return json.loads(self.body)
        except json.JSONDecodeError:
            return None
        except TypeError:
            return None

    @property
    def body(self):
        &#34;&#34;&#34;Get the body of the request as text.&#34;&#34;&#34;
        return self.data.decode(&#34;utf-8&#34;)


class HttpResponse(Response):
    &#34;&#34;&#34;Represents an HTTP Response to be generated by the Nitric Membrane in response to an HTTP Request Trigger.&#34;&#34;&#34;

    def __init__(self, status: int = 200, headers: Record = None, body: bytes = None):
        &#34;&#34;&#34;Construct a new HttpResponse.&#34;&#34;&#34;
        self.status = status
        self.headers = headers if headers else {}
        self._body = body if body else bytes()

    @property
    def body(self):
        &#34;&#34;&#34;Return the HTTP response body.&#34;&#34;&#34;
        return self._body

    @body.setter
    def body(self, value: Union[str, bytes, Any]):
        if isinstance(value, str):
            self._body = value.encode(&#34;utf-8&#34;)
        elif isinstance(value, bytes):
            self._body = value
        else:
            self._body = json.dumps(value).encode(&#34;utf-8&#34;)
            self.headers[&#34;Content-Type&#34;] = [&#34;application/json&#34;]


class HttpContext(TriggerContext):
    &#34;&#34;&#34;Represents the full request/response context for an Http based trigger.&#34;&#34;&#34;

    def __init__(self, request: HttpRequest, response: HttpResponse = None):
        &#34;&#34;&#34;Construct a new HttpContext.&#34;&#34;&#34;
        super().__init__()
        self.req = request
        self.res = response if response else HttpResponse()

    def http(self) -&gt; HttpContext:
        &#34;&#34;&#34;Return this HttpContext, used when determining the context type of a trigger.&#34;&#34;&#34;
        return self

    @staticmethod
    def from_grpc_trigger_request(trigger_request: TriggerRequest) -&gt; HttpContext:
        &#34;&#34;&#34;Construct a new HttpContext from an Http trigger from the Nitric Membrane.&#34;&#34;&#34;
        if len(trigger_request.http.headers.keys()) &gt; 0:
            headers = {k: v.value for (k, v) in trigger_request.http.headers.items()}
        else:
            headers = trigger_request.http.headers_old

        if len(trigger_request.http.query_params.keys()) &gt; 0:
            query = {k: v.value for (k, v) in trigger_request.http.query_params.items()}
        else:
            query = trigger_request.http.query_params_old

        return HttpContext(
            request=HttpRequest(
                data=trigger_request.data,
                method=trigger_request.http.method,
                query=query,
                path=trigger_request.http.path,
                params={k: v for (k, v) in trigger_request.http.path_params.items()},
                headers=headers,
                trace_context=trigger_request.trace_context,
            )
        )


class EventRequest(Request):
    &#34;&#34;&#34;Represents a translated Event, from a Subscribed Topic, forwarded from the Nitric Membrane.&#34;&#34;&#34;

    def __init__(self, data: bytes, topic: str, trace_context: Dict[str, str]):
        &#34;&#34;&#34;Construct a new EventRequest.&#34;&#34;&#34;
        super().__init__(data)
        self.topic = topic
        self.trace_context = trace_context

    @property
    def payload(self) -&gt; bytes:
        &#34;&#34;&#34;Return the payload of this request as text.&#34;&#34;&#34;
        return json.loads(self.data.decode(&#34;utf-8&#34;))


class EventResponse(Response):
    &#34;&#34;&#34;Represents the response to a trigger from an Event as a result of a Topic subscription.&#34;&#34;&#34;

    def __init__(self, success: bool = True):
        &#34;&#34;&#34;Construct a new EventResponse.&#34;&#34;&#34;
        self.success = success


class EventContext(TriggerContext):
    &#34;&#34;&#34;Represents the full request/response context for an Event based trigger.&#34;&#34;&#34;

    def __init__(self, request: EventRequest, response: EventResponse = None):
        &#34;&#34;&#34;Construct a new EventContext.&#34;&#34;&#34;
        super().__init__()
        self.req = request
        self.res = response if response else EventResponse()

    def event(self) -&gt; EventContext:
        &#34;&#34;&#34;Return this EventContext, used when determining the context type of a trigger.&#34;&#34;&#34;
        return self

    @staticmethod
    def from_grpc_trigger_request(trigger_request: TriggerRequest):
        &#34;&#34;&#34;Construct a new EventContext from an Event trigger from the Nitric Membrane.&#34;&#34;&#34;
        return EventContext(
            request=EventRequest(
                data=trigger_request.data,
                topic=trigger_request.topic.topic,
                trace_context=trigger_request.trace_context,
            )
        )


# async def face(inpp: int) -&gt; str:
#     return &#34;thing&#34;


# ====== Function Handlers ======

C = TypeVar(&#34;C&#34;, TriggerContext, HttpContext, EventContext)
Middleware = Callable
Handler = Coroutine[Any, Any, C]
HttpHandler = Coroutine[Any, Any, Optional[HttpContext]]
EventHandler = Coroutine[Any, Any, Optional[EventContext]]
Middleware = Callable[[C, Middleware], Handler]
HttpMiddleware = Callable[[HttpContext, HttpHandler], HttpHandler]
EventMiddleware = Callable[[EventContext, EventHandler], EventHandler]


def compose_middleware(*middlewares: Union[Middleware, List[Middleware]]) -&gt; Middleware:
    &#34;&#34;&#34;
    Compose multiple middleware functions into a single middleware function.

    The resulting middleware will effectively be a chain of the provided middleware,
    where each calls the next in the chain when they&#39;re successful.
    &#34;&#34;&#34;
    middlewares = list(middlewares)
    if len(middlewares) == 1 and not isinstance(middlewares[0], list):
        return middlewares[0]

    middlewares = [compose_middleware(m) if isinstance(m, list) else m for m in middlewares]

    async def handler(ctx, next_middleware=lambda ctx: ctx):
        def reduce_chain(acc_next, cur):
            async def chained_middleware(context):
                # Count the positional arguments to determine if the function is a handler or middleware.
                all_args = cur.__code__.co_argcount
                kwargs = len(cur.__defaults__) if cur.__defaults__ is not None else 0
                pos_args = all_args - kwargs
                if pos_args == 2:
                    # Call the middleware with next and return the result
                    return (
                        (await cur(context, acc_next)) if asyncio.iscoroutinefunction(cur) else cur(context, acc_next)
                    )
                else:
                    # Call the handler with ctx only, then call the remainder of the middleware chain
                    result = (await cur(context)) if asyncio.iscoroutinefunction(cur) else cur(context)
                    return (await acc_next(result)) if asyncio.iscoroutinefunction(acc_next) else acc_next(result)

            return chained_middleware

        middleware_chain = functools.reduce(reduce_chain, reversed(middlewares + [next_middleware]))
        return await middleware_chain(ctx)

    return handler


# ====== Function Server ======


def _create_internal_error_response(req: TriggerRequest) -&gt; TriggerResponse:
    &#34;&#34;&#34;Create a general error response based on the trigger request type.&#34;&#34;&#34;
    context_type, context = betterproto.which_one_of(req, &#34;context&#34;)
    if context_type == &#34;http&#34;:
        return TriggerResponse(data=bytes(), http=HttpResponseContext(status=500))
    elif context_type == &#34;topic&#34;:
        return TriggerResponse(data=bytes(), topic=TopicResponseContext(success=False))
    else:
        raise Exception(f&#34;Unknown trigger type: {context_type}, unable to generate expected response&#34;)


class ApiWorkerOptions:
    &#34;&#34;&#34;Options for API workers.&#34;&#34;&#34;

    def __init__(self, api: str, route: str, methods: List[Union[str, HttpMethod]], opts: MethodOptions):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.api = api
        self.route = route
        self.methods = [str(method) for method in methods]
        self.opts = opts


class RateWorkerOptions:
    &#34;&#34;&#34;Options for rate workers.&#34;&#34;&#34;

    description: str
    rate: int
    frequency: Frequency

    def __init__(self, description: str, rate: int, frequency: Frequency):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.description = description
        self.rate = rate
        self.frequency = frequency


class SubscriptionWorkerOptions:
    &#34;&#34;&#34;Options for subscription workers.&#34;&#34;&#34;

    def __init__(self, topic: str):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.topic = topic


class Frequency(Enum):
    &#34;&#34;&#34;Valid schedule frequencies.&#34;&#34;&#34;

    seconds = &#34;seconds&#34;
    minutes = &#34;minutes&#34;
    hours = &#34;hours&#34;
    days = &#34;days&#34;

    @staticmethod
    def from_str(value: str) -&gt; Frequency:
        &#34;&#34;&#34;Convert a string frequency value to a Frequency.&#34;&#34;&#34;
        return Frequency[value.strip().lower()]

    @staticmethod
    def as_str_list() -&gt; List[str]:
        &#34;&#34;&#34;Return all frequency values as a list of strings.&#34;&#34;&#34;
        return [str(frequency.value) for frequency in Frequency]


class MethodOptions:
    &#34;&#34;&#34;Represents options when defining a method handler.&#34;&#34;&#34;

    security: dict[str, List[str]]

    def __init__(self, security: dict[str, List[str]] = None):
        &#34;&#34;&#34;Construct a new HTTP method options object.&#34;&#34;&#34;
        self.security = security


class FaasWorkerOptions:
    &#34;&#34;&#34;Empty worker options for generic function handlers.&#34;&#34;&#34;

    pass


FaasClientOptions = Union[ApiWorkerOptions, RateWorkerOptions, SubscriptionWorkerOptions, FaasWorkerOptions]


class FunctionServer:
    &#34;&#34;&#34;A Function as a Service server, which acts as a faas handler for the Nitric Membrane.&#34;&#34;&#34;

    def __init__(self, opts: FaasClientOptions):
        &#34;&#34;&#34;Construct a new function server.&#34;&#34;&#34;
        self.__http_handler = None
        self.__event_handler = None
        self._any_handler = None
        self._opts = opts

    def http(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
        &#34;&#34;&#34;
        Register one or more HTTP Trigger Handlers or Middleware.

        When multiple handlers are provided, they will be called in order.
        &#34;&#34;&#34;
        self.__http_handler = compose_middleware(*handlers)
        return self

    def event(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
        &#34;&#34;&#34;
        Register one or more Event Trigger Handlers or Middleware.

        When multiple handlers are provided, they will be called in order.
        &#34;&#34;&#34;
        self.__event_handler = compose_middleware(*handlers)
        return self

    async def start(self, *handlers: Union[Middleware, List[Middleware]]):
        &#34;&#34;&#34;Start the function server using the provided trigger handlers.&#34;&#34;&#34;
        self._any_handler = compose_middleware(*handlers) if len(handlers) &gt; 0 else None
        if not self._any_handler and not self._http_handler and not self._event_handler:
            raise Exception(&#34;At least one handler function must be provided.&#34;)

        await self._run()

    @property
    def _http_handler(self):
        return self.__http_handler if self.__http_handler else self._any_handler

    @property
    def _event_handler(self):
        return self.__event_handler if self.__event_handler else self._any_handler

    async def _run(self):
        &#34;&#34;&#34;Register a new FaaS worker with the Membrane, using the provided function as the handler.&#34;&#34;&#34;
        channel = new_default_channel()
        client = FaasServiceStub(channel)
        request_channel = AsyncChannel(close=True)
        # We can start be sending all the requests we already have
        try:
            init_request = InitRequest()
            # Construct init request based on API worker options
            if isinstance(self._opts, ApiWorkerOptions):
                init_request = InitRequest(
                    api=ApiWorker(api=self._opts.api, path=self._opts.route, methods=self._opts.methods)
                )
            elif isinstance(self._opts, RateWorkerOptions):
                # TODO: Populate rate
                init_request = InitRequest(
                    schedule=ScheduleWorker(
                        key=self._opts.description, rate=ScheduleRate(rate=f&#34;{self._opts.rate} {self._opts.frequency}&#34;)
                    )
                )
            elif isinstance(self._opts, SubscriptionWorkerOptions):
                init_request = InitRequest(subscription=SubscriptionWorker(topic=self._opts.topic))

            # let the membrane server know we&#39;re ready to start
            await request_channel.send(ClientMessage(init_request=init_request))
            async for srv_msg in client.trigger_stream(request_channel):
                # The response iterator will remain active until the connection is closed
                msg_type, val = betterproto.which_one_of(srv_msg, &#34;content&#34;)

                if msg_type == &#34;init_response&#34;:
                    print(&#34;function connected to Membrane&#34;)
                    # We don&#39;t need to reply
                    # proceed to the next available message
                    continue
                if msg_type == &#34;trigger_request&#34;:
                    ctx = _ctx_from_grpc_trigger_request(srv_msg.trigger_request)

                    try:
                        if len(ctx.req.trace_context) &gt; 0:
                            context.attach(PROPAGATOR().extract(ctx.req.trace_context))

                        if ctx.http():
                            func = self._http_handler
                        elif ctx.event():
                            func = self._event_handler
                        else:
                            func = self._any_handler

                        response_ctx = (await func(ctx)) if asyncio.iscoroutinefunction(func) else func(ctx)

                        if response_ctx is None:
                            response_ctx = ctx

                        # Send function response back to server
                        await request_channel.send(
                            ClientMessage(
                                id=srv_msg.id,
                                trigger_response=_grpc_response_from_ctx(response_ctx),
                            )
                        )
                    except Exception:
                        # Any unhandled exceptions in the above code will end the loop
                        # and stop processing future triggers, we catch them here as a last resort.
                        print(&#34;An unexpected error occurred processing trigger or response&#34;)
                        traceback.print_exc()
                        response = _create_internal_error_response(srv_msg.trigger_request)
                        await request_channel.send(ClientMessage(id=srv_msg.id, trigger_response=response))
                else:
                    print(f&#34;unhandled message type {msg_type}, skipping&#34;)
                    continue
                if request_channel.done():
                    break
        except grpclib.exceptions.StreamTerminatedError:
            print(&#34;stream from Membrane closed, closing client stream&#34;)
        except asyncio.CancelledError:
            # Membrane has closed stream after init
            print(&#34;stream from Membrane closed, closing client stream&#34;)
        except ConnectionRefusedError as cre:
            traceback.print_exc()
            raise ConnectionRefusedError(&#34;Failed to register function with Membrane&#34;) from cre
        except Exception as e:
            traceback.print_exc()
            raise Exception(&#34;An unexpected error occurred.&#34;) from e
        finally:
            # The channel must be closed to complete the gRPC connection
            request_channel.close()
            channel.close()


# Convenience functions to create function servers


def http(*handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Create a new Function Server and Register one or more HTTP Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    return FunctionServer(opts=[]).http(*handlers)


def event(*handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Create a new Function Server and Register one or more Event Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    return FunctionServer(opts=[]).event(*handlers)


def start(*handlers: Union[Middleware, List[Middleware]]):
    &#34;&#34;&#34;Create a new Function Server and start it using the provided trigger handlers.&#34;&#34;&#34;
    if len(handlers) &lt; 1:
        raise Exception(&#34;At least one handler must be provided.&#34;)
    return FunctionServer(opts=[]).start(*handlers)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nitric.faas.compose_middleware"><code class="name flex">
<span>def <span class="ident">compose_middleware</span></span>(<span>*middlewares: Union[Middleware, List[Middleware]]) ‑> Callable[[~C, Callable], Coroutine[Any, Any, ~C]]</span>
</code></dt>
<dd>
<div class="desc"><p>Compose multiple middleware functions into a single middleware function.</p>
<p>The resulting middleware will effectively be a chain of the provided middleware,
where each calls the next in the chain when they're successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose_middleware(*middlewares: Union[Middleware, List[Middleware]]) -&gt; Middleware:
    &#34;&#34;&#34;
    Compose multiple middleware functions into a single middleware function.

    The resulting middleware will effectively be a chain of the provided middleware,
    where each calls the next in the chain when they&#39;re successful.
    &#34;&#34;&#34;
    middlewares = list(middlewares)
    if len(middlewares) == 1 and not isinstance(middlewares[0], list):
        return middlewares[0]

    middlewares = [compose_middleware(m) if isinstance(m, list) else m for m in middlewares]

    async def handler(ctx, next_middleware=lambda ctx: ctx):
        def reduce_chain(acc_next, cur):
            async def chained_middleware(context):
                # Count the positional arguments to determine if the function is a handler or middleware.
                all_args = cur.__code__.co_argcount
                kwargs = len(cur.__defaults__) if cur.__defaults__ is not None else 0
                pos_args = all_args - kwargs
                if pos_args == 2:
                    # Call the middleware with next and return the result
                    return (
                        (await cur(context, acc_next)) if asyncio.iscoroutinefunction(cur) else cur(context, acc_next)
                    )
                else:
                    # Call the handler with ctx only, then call the remainder of the middleware chain
                    result = (await cur(context)) if asyncio.iscoroutinefunction(cur) else cur(context)
                    return (await acc_next(result)) if asyncio.iscoroutinefunction(acc_next) else acc_next(result)

            return chained_middleware

        middleware_chain = functools.reduce(reduce_chain, reversed(middlewares + [next_middleware]))
        return await middleware_chain(ctx)

    return handler</code></pre>
</details>
</dd>
<dt id="nitric.faas.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>*handlers: Union[Middleware, List[Middleware]]) ‑> <a title="nitric.faas.FunctionServer" href="#nitric.faas.FunctionServer">FunctionServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Function Server and Register one or more Event Trigger Handlers or Middleware.</p>
<p>When multiple handlers are provided, they will be called in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(*handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Create a new Function Server and Register one or more Event Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    return FunctionServer(opts=[]).event(*handlers)</code></pre>
</details>
</dd>
<dt id="nitric.faas.http"><code class="name flex">
<span>def <span class="ident">http</span></span>(<span>*handlers: Union[Middleware, List[Middleware]]) ‑> <a title="nitric.faas.FunctionServer" href="#nitric.faas.FunctionServer">FunctionServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Function Server and Register one or more HTTP Trigger Handlers or Middleware.</p>
<p>When multiple handlers are provided, they will be called in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def http(*handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Create a new Function Server and Register one or more HTTP Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    return FunctionServer(opts=[]).http(*handlers)</code></pre>
</details>
</dd>
<dt id="nitric.faas.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>*handlers: Union[Middleware, List[Middleware]])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Function Server and start it using the provided trigger handlers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(*handlers: Union[Middleware, List[Middleware]]):
    &#34;&#34;&#34;Create a new Function Server and start it using the provided trigger handlers.&#34;&#34;&#34;
    if len(handlers) &lt; 1:
        raise Exception(&#34;At least one handler must be provided.&#34;)
    return FunctionServer(opts=[]).start(*handlers)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nitric.faas.ApiWorkerOptions"><code class="flex name class">
<span>class <span class="ident">ApiWorkerOptions</span></span>
<span>(</span><span>api: str, route: str, methods: List[Union[str, <a title="nitric.faas.HttpMethod" href="#nitric.faas.HttpMethod">HttpMethod</a>]], opts: <a title="nitric.faas.MethodOptions" href="#nitric.faas.MethodOptions">MethodOptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for API workers.</p>
<p>Construct a new options object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApiWorkerOptions:
    &#34;&#34;&#34;Options for API workers.&#34;&#34;&#34;

    def __init__(self, api: str, route: str, methods: List[Union[str, HttpMethod]], opts: MethodOptions):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.api = api
        self.route = route
        self.methods = [str(method) for method in methods]
        self.opts = opts</code></pre>
</details>
</dd>
<dt id="nitric.faas.EventContext"><code class="flex name class">
<span>class <span class="ident">EventContext</span></span>
<span>(</span><span>request: <a title="nitric.faas.EventRequest" href="#nitric.faas.EventRequest">EventRequest</a>, response: <a title="nitric.faas.EventResponse" href="#nitric.faas.EventResponse">EventResponse</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the full request/response context for an Event based trigger.</p>
<p>Construct a new EventContext.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventContext(TriggerContext):
    &#34;&#34;&#34;Represents the full request/response context for an Event based trigger.&#34;&#34;&#34;

    def __init__(self, request: EventRequest, response: EventResponse = None):
        &#34;&#34;&#34;Construct a new EventContext.&#34;&#34;&#34;
        super().__init__()
        self.req = request
        self.res = response if response else EventResponse()

    def event(self) -&gt; EventContext:
        &#34;&#34;&#34;Return this EventContext, used when determining the context type of a trigger.&#34;&#34;&#34;
        return self

    @staticmethod
    def from_grpc_trigger_request(trigger_request: TriggerRequest):
        &#34;&#34;&#34;Construct a new EventContext from an Event trigger from the Nitric Membrane.&#34;&#34;&#34;
        return EventContext(
            request=EventRequest(
                data=trigger_request.data,
                topic=trigger_request.topic.topic,
                trace_context=trigger_request.trace_context,
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.TriggerContext" href="#nitric.faas.TriggerContext">TriggerContext</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="nitric.faas.EventContext.from_grpc_trigger_request"><code class="name flex">
<span>def <span class="ident">from_grpc_trigger_request</span></span>(<span>trigger_request: TriggerRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a new EventContext from an Event trigger from the Nitric Membrane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_grpc_trigger_request(trigger_request: TriggerRequest):
    &#34;&#34;&#34;Construct a new EventContext from an Event trigger from the Nitric Membrane.&#34;&#34;&#34;
    return EventContext(
        request=EventRequest(
            data=trigger_request.data,
            topic=trigger_request.topic.topic,
            trace_context=trigger_request.trace_context,
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nitric.faas.EventContext.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self) ‑> <a title="nitric.faas.EventContext" href="#nitric.faas.EventContext">EventContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return this EventContext, used when determining the context type of a trigger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self) -&gt; EventContext:
    &#34;&#34;&#34;Return this EventContext, used when determining the context type of a trigger.&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nitric.faas.TriggerContext" href="#nitric.faas.TriggerContext">TriggerContext</a></b></code>:
<ul class="hlist">
<li><code><a title="nitric.faas.TriggerContext.http" href="#nitric.faas.TriggerContext.http">http</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nitric.faas.EventRequest"><code class="flex name class">
<span>class <span class="ident">EventRequest</span></span>
<span>(</span><span>data: bytes, topic: str, trace_context: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a translated Event, from a Subscribed Topic, forwarded from the Nitric Membrane.</p>
<p>Construct a new EventRequest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventRequest(Request):
    &#34;&#34;&#34;Represents a translated Event, from a Subscribed Topic, forwarded from the Nitric Membrane.&#34;&#34;&#34;

    def __init__(self, data: bytes, topic: str, trace_context: Dict[str, str]):
        &#34;&#34;&#34;Construct a new EventRequest.&#34;&#34;&#34;
        super().__init__(data)
        self.topic = topic
        self.trace_context = trace_context

    @property
    def payload(self) -&gt; bytes:
        &#34;&#34;&#34;Return the payload of this request as text.&#34;&#34;&#34;
        return json.loads(self.data.decode(&#34;utf-8&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.Request" href="#nitric.faas.Request">Request</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="nitric.faas.EventRequest.payload"><code class="name">var <span class="ident">payload</span> : bytes</code></dt>
<dd>
<div class="desc"><p>Return the payload of this request as text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def payload(self) -&gt; bytes:
    &#34;&#34;&#34;Return the payload of this request as text.&#34;&#34;&#34;
    return json.loads(self.data.decode(&#34;utf-8&#34;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nitric.faas.EventResponse"><code class="flex name class">
<span>class <span class="ident">EventResponse</span></span>
<span>(</span><span>success: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the response to a trigger from an Event as a result of a Topic subscription.</p>
<p>Construct a new EventResponse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventResponse(Response):
    &#34;&#34;&#34;Represents the response to a trigger from an Event as a result of a Topic subscription.&#34;&#34;&#34;

    def __init__(self, success: bool = True):
        &#34;&#34;&#34;Construct a new EventResponse.&#34;&#34;&#34;
        self.success = success</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.Response" href="#nitric.faas.Response">Response</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="nitric.faas.FaasWorkerOptions"><code class="flex name class">
<span>class <span class="ident">FaasWorkerOptions</span></span>
</code></dt>
<dd>
<div class="desc"><p>Empty worker options for generic function handlers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FaasWorkerOptions:
    &#34;&#34;&#34;Empty worker options for generic function handlers.&#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="nitric.faas.Frequency"><code class="flex name class">
<span>class <span class="ident">Frequency</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Valid schedule frequencies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frequency(Enum):
    &#34;&#34;&#34;Valid schedule frequencies.&#34;&#34;&#34;

    seconds = &#34;seconds&#34;
    minutes = &#34;minutes&#34;
    hours = &#34;hours&#34;
    days = &#34;days&#34;

    @staticmethod
    def from_str(value: str) -&gt; Frequency:
        &#34;&#34;&#34;Convert a string frequency value to a Frequency.&#34;&#34;&#34;
        return Frequency[value.strip().lower()]

    @staticmethod
    def as_str_list() -&gt; List[str]:
        &#34;&#34;&#34;Return all frequency values as a list of strings.&#34;&#34;&#34;
        return [str(frequency.value) for frequency in Frequency]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.faas.Frequency.days"><code class="name">var <span class="ident">days</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.Frequency.hours"><code class="name">var <span class="ident">hours</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.Frequency.minutes"><code class="name">var <span class="ident">minutes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.Frequency.seconds"><code class="name">var <span class="ident">seconds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nitric.faas.Frequency.as_str_list"><code class="name flex">
<span>def <span class="ident">as_str_list</span></span>(<span>) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all frequency values as a list of strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def as_str_list() -&gt; List[str]:
    &#34;&#34;&#34;Return all frequency values as a list of strings.&#34;&#34;&#34;
    return [str(frequency.value) for frequency in Frequency]</code></pre>
</details>
</dd>
<dt id="nitric.faas.Frequency.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>value: str) ‑> <a title="nitric.faas.Frequency" href="#nitric.faas.Frequency">Frequency</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string frequency value to a Frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(value: str) -&gt; Frequency:
    &#34;&#34;&#34;Convert a string frequency value to a Frequency.&#34;&#34;&#34;
    return Frequency[value.strip().lower()]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nitric.faas.FunctionServer"><code class="flex name class">
<span>class <span class="ident">FunctionServer</span></span>
<span>(</span><span>opts: FaasClientOptions)</span>
</code></dt>
<dd>
<div class="desc"><p>A Function as a Service server, which acts as a faas handler for the Nitric Membrane.</p>
<p>Construct a new function server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionServer:
    &#34;&#34;&#34;A Function as a Service server, which acts as a faas handler for the Nitric Membrane.&#34;&#34;&#34;

    def __init__(self, opts: FaasClientOptions):
        &#34;&#34;&#34;Construct a new function server.&#34;&#34;&#34;
        self.__http_handler = None
        self.__event_handler = None
        self._any_handler = None
        self._opts = opts

    def http(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
        &#34;&#34;&#34;
        Register one or more HTTP Trigger Handlers or Middleware.

        When multiple handlers are provided, they will be called in order.
        &#34;&#34;&#34;
        self.__http_handler = compose_middleware(*handlers)
        return self

    def event(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
        &#34;&#34;&#34;
        Register one or more Event Trigger Handlers or Middleware.

        When multiple handlers are provided, they will be called in order.
        &#34;&#34;&#34;
        self.__event_handler = compose_middleware(*handlers)
        return self

    async def start(self, *handlers: Union[Middleware, List[Middleware]]):
        &#34;&#34;&#34;Start the function server using the provided trigger handlers.&#34;&#34;&#34;
        self._any_handler = compose_middleware(*handlers) if len(handlers) &gt; 0 else None
        if not self._any_handler and not self._http_handler and not self._event_handler:
            raise Exception(&#34;At least one handler function must be provided.&#34;)

        await self._run()

    @property
    def _http_handler(self):
        return self.__http_handler if self.__http_handler else self._any_handler

    @property
    def _event_handler(self):
        return self.__event_handler if self.__event_handler else self._any_handler

    async def _run(self):
        &#34;&#34;&#34;Register a new FaaS worker with the Membrane, using the provided function as the handler.&#34;&#34;&#34;
        channel = new_default_channel()
        client = FaasServiceStub(channel)
        request_channel = AsyncChannel(close=True)
        # We can start be sending all the requests we already have
        try:
            init_request = InitRequest()
            # Construct init request based on API worker options
            if isinstance(self._opts, ApiWorkerOptions):
                init_request = InitRequest(
                    api=ApiWorker(api=self._opts.api, path=self._opts.route, methods=self._opts.methods)
                )
            elif isinstance(self._opts, RateWorkerOptions):
                # TODO: Populate rate
                init_request = InitRequest(
                    schedule=ScheduleWorker(
                        key=self._opts.description, rate=ScheduleRate(rate=f&#34;{self._opts.rate} {self._opts.frequency}&#34;)
                    )
                )
            elif isinstance(self._opts, SubscriptionWorkerOptions):
                init_request = InitRequest(subscription=SubscriptionWorker(topic=self._opts.topic))

            # let the membrane server know we&#39;re ready to start
            await request_channel.send(ClientMessage(init_request=init_request))
            async for srv_msg in client.trigger_stream(request_channel):
                # The response iterator will remain active until the connection is closed
                msg_type, val = betterproto.which_one_of(srv_msg, &#34;content&#34;)

                if msg_type == &#34;init_response&#34;:
                    print(&#34;function connected to Membrane&#34;)
                    # We don&#39;t need to reply
                    # proceed to the next available message
                    continue
                if msg_type == &#34;trigger_request&#34;:
                    ctx = _ctx_from_grpc_trigger_request(srv_msg.trigger_request)

                    try:
                        if len(ctx.req.trace_context) &gt; 0:
                            context.attach(PROPAGATOR().extract(ctx.req.trace_context))

                        if ctx.http():
                            func = self._http_handler
                        elif ctx.event():
                            func = self._event_handler
                        else:
                            func = self._any_handler

                        response_ctx = (await func(ctx)) if asyncio.iscoroutinefunction(func) else func(ctx)

                        if response_ctx is None:
                            response_ctx = ctx

                        # Send function response back to server
                        await request_channel.send(
                            ClientMessage(
                                id=srv_msg.id,
                                trigger_response=_grpc_response_from_ctx(response_ctx),
                            )
                        )
                    except Exception:
                        # Any unhandled exceptions in the above code will end the loop
                        # and stop processing future triggers, we catch them here as a last resort.
                        print(&#34;An unexpected error occurred processing trigger or response&#34;)
                        traceback.print_exc()
                        response = _create_internal_error_response(srv_msg.trigger_request)
                        await request_channel.send(ClientMessage(id=srv_msg.id, trigger_response=response))
                else:
                    print(f&#34;unhandled message type {msg_type}, skipping&#34;)
                    continue
                if request_channel.done():
                    break
        except grpclib.exceptions.StreamTerminatedError:
            print(&#34;stream from Membrane closed, closing client stream&#34;)
        except asyncio.CancelledError:
            # Membrane has closed stream after init
            print(&#34;stream from Membrane closed, closing client stream&#34;)
        except ConnectionRefusedError as cre:
            traceback.print_exc()
            raise ConnectionRefusedError(&#34;Failed to register function with Membrane&#34;) from cre
        except Exception as e:
            traceback.print_exc()
            raise Exception(&#34;An unexpected error occurred.&#34;) from e
        finally:
            # The channel must be closed to complete the gRPC connection
            request_channel.close()
            channel.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nitric.faas.FunctionServer.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self, *handlers: Union[Middleware, List[Middleware]]) ‑> <a title="nitric.faas.FunctionServer" href="#nitric.faas.FunctionServer">FunctionServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register one or more Event Trigger Handlers or Middleware.</p>
<p>When multiple handlers are provided, they will be called in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Register one or more Event Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    self.__event_handler = compose_middleware(*handlers)
    return self</code></pre>
</details>
</dd>
<dt id="nitric.faas.FunctionServer.http"><code class="name flex">
<span>def <span class="ident">http</span></span>(<span>self, *handlers: Union[Middleware, List[Middleware]]) ‑> <a title="nitric.faas.FunctionServer" href="#nitric.faas.FunctionServer">FunctionServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register one or more HTTP Trigger Handlers or Middleware.</p>
<p>When multiple handlers are provided, they will be called in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def http(self, *handlers: Union[Middleware, List[Middleware]]) -&gt; FunctionServer:
    &#34;&#34;&#34;
    Register one or more HTTP Trigger Handlers or Middleware.

    When multiple handlers are provided, they will be called in order.
    &#34;&#34;&#34;
    self.__http_handler = compose_middleware(*handlers)
    return self</code></pre>
</details>
</dd>
<dt id="nitric.faas.FunctionServer.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self, *handlers: Union[Middleware, List[Middleware]])</span>
</code></dt>
<dd>
<div class="desc"><p>Start the function server using the provided trigger handlers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(self, *handlers: Union[Middleware, List[Middleware]]):
    &#34;&#34;&#34;Start the function server using the provided trigger handlers.&#34;&#34;&#34;
    self._any_handler = compose_middleware(*handlers) if len(handlers) &gt; 0 else None
    if not self._any_handler and not self._http_handler and not self._event_handler:
        raise Exception(&#34;At least one handler function must be provided.&#34;)

    await self._run()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nitric.faas.HttpContext"><code class="flex name class">
<span>class <span class="ident">HttpContext</span></span>
<span>(</span><span>request: <a title="nitric.faas.HttpRequest" href="#nitric.faas.HttpRequest">HttpRequest</a>, response: <a title="nitric.faas.HttpResponse" href="#nitric.faas.HttpResponse">HttpResponse</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the full request/response context for an Http based trigger.</p>
<p>Construct a new HttpContext.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpContext(TriggerContext):
    &#34;&#34;&#34;Represents the full request/response context for an Http based trigger.&#34;&#34;&#34;

    def __init__(self, request: HttpRequest, response: HttpResponse = None):
        &#34;&#34;&#34;Construct a new HttpContext.&#34;&#34;&#34;
        super().__init__()
        self.req = request
        self.res = response if response else HttpResponse()

    def http(self) -&gt; HttpContext:
        &#34;&#34;&#34;Return this HttpContext, used when determining the context type of a trigger.&#34;&#34;&#34;
        return self

    @staticmethod
    def from_grpc_trigger_request(trigger_request: TriggerRequest) -&gt; HttpContext:
        &#34;&#34;&#34;Construct a new HttpContext from an Http trigger from the Nitric Membrane.&#34;&#34;&#34;
        if len(trigger_request.http.headers.keys()) &gt; 0:
            headers = {k: v.value for (k, v) in trigger_request.http.headers.items()}
        else:
            headers = trigger_request.http.headers_old

        if len(trigger_request.http.query_params.keys()) &gt; 0:
            query = {k: v.value for (k, v) in trigger_request.http.query_params.items()}
        else:
            query = trigger_request.http.query_params_old

        return HttpContext(
            request=HttpRequest(
                data=trigger_request.data,
                method=trigger_request.http.method,
                query=query,
                path=trigger_request.http.path,
                params={k: v for (k, v) in trigger_request.http.path_params.items()},
                headers=headers,
                trace_context=trigger_request.trace_context,
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.TriggerContext" href="#nitric.faas.TriggerContext">TriggerContext</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="nitric.faas.HttpContext.from_grpc_trigger_request"><code class="name flex">
<span>def <span class="ident">from_grpc_trigger_request</span></span>(<span>trigger_request: TriggerRequest) ‑> <a title="nitric.faas.HttpContext" href="#nitric.faas.HttpContext">HttpContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a new HttpContext from an Http trigger from the Nitric Membrane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_grpc_trigger_request(trigger_request: TriggerRequest) -&gt; HttpContext:
    &#34;&#34;&#34;Construct a new HttpContext from an Http trigger from the Nitric Membrane.&#34;&#34;&#34;
    if len(trigger_request.http.headers.keys()) &gt; 0:
        headers = {k: v.value for (k, v) in trigger_request.http.headers.items()}
    else:
        headers = trigger_request.http.headers_old

    if len(trigger_request.http.query_params.keys()) &gt; 0:
        query = {k: v.value for (k, v) in trigger_request.http.query_params.items()}
    else:
        query = trigger_request.http.query_params_old

    return HttpContext(
        request=HttpRequest(
            data=trigger_request.data,
            method=trigger_request.http.method,
            query=query,
            path=trigger_request.http.path,
            params={k: v for (k, v) in trigger_request.http.path_params.items()},
            headers=headers,
            trace_context=trigger_request.trace_context,
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nitric.faas.HttpContext.http"><code class="name flex">
<span>def <span class="ident">http</span></span>(<span>self) ‑> <a title="nitric.faas.HttpContext" href="#nitric.faas.HttpContext">HttpContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return this HttpContext, used when determining the context type of a trigger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def http(self) -&gt; HttpContext:
    &#34;&#34;&#34;Return this HttpContext, used when determining the context type of a trigger.&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nitric.faas.TriggerContext" href="#nitric.faas.TriggerContext">TriggerContext</a></b></code>:
<ul class="hlist">
<li><code><a title="nitric.faas.TriggerContext.event" href="#nitric.faas.TriggerContext.event">event</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nitric.faas.HttpMethod"><code class="flex name class">
<span>class <span class="ident">HttpMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Valid query expression operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpMethod(Enum):
    &#34;&#34;&#34;Valid query expression operators.&#34;&#34;&#34;

    GET = &#34;GET&#34;
    POST = &#34;POST&#34;
    PUT = &#34;PUT&#34;
    DELETE = &#34;DELETE&#34;
    PATCH = &#34;PATCH&#34;
    OPTIONS = &#34;OPTIONS&#34;

    def __str__(self):
        return str(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nitric.faas.HttpMethod.DELETE"><code class="name">var <span class="ident">DELETE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.HttpMethod.GET"><code class="name">var <span class="ident">GET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.HttpMethod.OPTIONS"><code class="name">var <span class="ident">OPTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.HttpMethod.PATCH"><code class="name">var <span class="ident">PATCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.HttpMethod.POST"><code class="name">var <span class="ident">POST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.HttpMethod.PUT"><code class="name">var <span class="ident">PUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nitric.faas.HttpRequest"><code class="flex name class">
<span>class <span class="ident">HttpRequest</span></span>
<span>(</span><span>data: bytes, method: str, path: str, params: Dict[str, str], query: Record, headers: Record, trace_context: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a translated Http Request forwarded from the Nitric Membrane.</p>
<p>Construct a new HttpRequest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpRequest(Request):
    &#34;&#34;&#34;Represents a translated Http Request forwarded from the Nitric Membrane.&#34;&#34;&#34;

    def __init__(
        self,
        data: bytes,
        method: str,
        path: str,
        params: Dict[str, str],
        query: Record,
        headers: Record,
        trace_context: Dict[str, str],
    ):
        &#34;&#34;&#34;Construct a new HttpRequest.&#34;&#34;&#34;
        super().__init__(data)
        self.method = method
        self.path = path
        self.params = params
        self.query = query
        self.headers = headers
        self.trace_context = trace_context

    @property
    def json(self) -&gt; Optional[Any]:
        &#34;&#34;&#34;Get the body of the request as JSON, returns None if request body is not JSON.&#34;&#34;&#34;
        try:
            return json.loads(self.body)
        except json.JSONDecodeError:
            return None
        except TypeError:
            return None

    @property
    def body(self):
        &#34;&#34;&#34;Get the body of the request as text.&#34;&#34;&#34;
        return self.data.decode(&#34;utf-8&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.Request" href="#nitric.faas.Request">Request</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="nitric.faas.HttpRequest.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<div class="desc"><p>Get the body of the request as text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body(self):
    &#34;&#34;&#34;Get the body of the request as text.&#34;&#34;&#34;
    return self.data.decode(&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="nitric.faas.HttpRequest.json"><code class="name">var <span class="ident">json</span> : Optional[Any]</code></dt>
<dd>
<div class="desc"><p>Get the body of the request as JSON, returns None if request body is not JSON.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def json(self) -&gt; Optional[Any]:
    &#34;&#34;&#34;Get the body of the request as JSON, returns None if request body is not JSON.&#34;&#34;&#34;
    try:
        return json.loads(self.body)
    except json.JSONDecodeError:
        return None
    except TypeError:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nitric.faas.HttpResponse"><code class="flex name class">
<span>class <span class="ident">HttpResponse</span></span>
<span>(</span><span>status: int = 200, headers: Record = None, body: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an HTTP Response to be generated by the Nitric Membrane in response to an HTTP Request Trigger.</p>
<p>Construct a new HttpResponse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpResponse(Response):
    &#34;&#34;&#34;Represents an HTTP Response to be generated by the Nitric Membrane in response to an HTTP Request Trigger.&#34;&#34;&#34;

    def __init__(self, status: int = 200, headers: Record = None, body: bytes = None):
        &#34;&#34;&#34;Construct a new HttpResponse.&#34;&#34;&#34;
        self.status = status
        self.headers = headers if headers else {}
        self._body = body if body else bytes()

    @property
    def body(self):
        &#34;&#34;&#34;Return the HTTP response body.&#34;&#34;&#34;
        return self._body

    @body.setter
    def body(self, value: Union[str, bytes, Any]):
        if isinstance(value, str):
            self._body = value.encode(&#34;utf-8&#34;)
        elif isinstance(value, bytes):
            self._body = value
        else:
            self._body = json.dumps(value).encode(&#34;utf-8&#34;)
            self.headers[&#34;Content-Type&#34;] = [&#34;application/json&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nitric.faas.Response" href="#nitric.faas.Response">Response</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="nitric.faas.HttpResponse.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<div class="desc"><p>Return the HTTP response body.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body(self):
    &#34;&#34;&#34;Return the HTTP response body.&#34;&#34;&#34;
    return self._body</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nitric.faas.MethodOptions"><code class="flex name class">
<span>class <span class="ident">MethodOptions</span></span>
<span>(</span><span>security: dict[str, List[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents options when defining a method handler.</p>
<p>Construct a new HTTP method options object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MethodOptions:
    &#34;&#34;&#34;Represents options when defining a method handler.&#34;&#34;&#34;

    security: dict[str, List[str]]

    def __init__(self, security: dict[str, List[str]] = None):
        &#34;&#34;&#34;Construct a new HTTP method options object.&#34;&#34;&#34;
        self.security = security</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nitric.faas.MethodOptions.security"><code class="name">var <span class="ident">security</span> : dict[str, typing.List[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nitric.faas.RateWorkerOptions"><code class="flex name class">
<span>class <span class="ident">RateWorkerOptions</span></span>
<span>(</span><span>description: str, rate: int, frequency: <a title="nitric.faas.Frequency" href="#nitric.faas.Frequency">Frequency</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for rate workers.</p>
<p>Construct a new options object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RateWorkerOptions:
    &#34;&#34;&#34;Options for rate workers.&#34;&#34;&#34;

    description: str
    rate: int
    frequency: Frequency

    def __init__(self, description: str, rate: int, frequency: Frequency):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.description = description
        self.rate = rate
        self.frequency = frequency</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nitric.faas.RateWorkerOptions.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.RateWorkerOptions.frequency"><code class="name">var <span class="ident">frequency</span> : <a title="nitric.faas.Frequency" href="#nitric.faas.Frequency">Frequency</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nitric.faas.RateWorkerOptions.rate"><code class="name">var <span class="ident">rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nitric.faas.Request"><code class="flex name class">
<span>class <span class="ident">Request</span></span>
<span>(</span><span>data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an abstract trigger request.</p>
<p>Construct a new Request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Request(ABC):
    &#34;&#34;&#34;Represents an abstract trigger request.&#34;&#34;&#34;

    def __init__(self, data: bytes):
        &#34;&#34;&#34;Construct a new Request.&#34;&#34;&#34;
        self.data = data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nitric.faas.EventRequest" href="#nitric.faas.EventRequest">EventRequest</a></li>
<li><a title="nitric.faas.HttpRequest" href="#nitric.faas.HttpRequest">HttpRequest</a></li>
</ul>
</dd>
<dt id="nitric.faas.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents an abstract trigger response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response(ABC):
    &#34;&#34;&#34;Represents an abstract trigger response.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nitric.faas.EventResponse" href="#nitric.faas.EventResponse">EventResponse</a></li>
<li><a title="nitric.faas.HttpResponse" href="#nitric.faas.HttpResponse">HttpResponse</a></li>
</ul>
</dd>
<dt id="nitric.faas.SubscriptionWorkerOptions"><code class="flex name class">
<span>class <span class="ident">SubscriptionWorkerOptions</span></span>
<span>(</span><span>topic: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for subscription workers.</p>
<p>Construct a new options object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubscriptionWorkerOptions:
    &#34;&#34;&#34;Options for subscription workers.&#34;&#34;&#34;

    def __init__(self, topic: str):
        &#34;&#34;&#34;Construct a new options object.&#34;&#34;&#34;
        self.topic = topic</code></pre>
</details>
</dd>
<dt id="nitric.faas.TriggerContext"><code class="flex name class">
<span>class <span class="ident">TriggerContext</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents an abstract request/response context for any trigger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriggerContext(ABC):
    &#34;&#34;&#34;Represents an abstract request/response context for any trigger.&#34;&#34;&#34;

    def http(self) -&gt; Union[HttpContext, None]:
        &#34;&#34;&#34;Return this context as an HttpContext if it is one, otherwise returns None.&#34;&#34;&#34;
        return None

    def event(self) -&gt; Union[EventContext, None]:
        &#34;&#34;&#34;Return this context as an EventContext if it is one, otherwise returns None.&#34;&#34;&#34;
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nitric.faas.EventContext" href="#nitric.faas.EventContext">EventContext</a></li>
<li><a title="nitric.faas.HttpContext" href="#nitric.faas.HttpContext">HttpContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nitric.faas.TriggerContext.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self) ‑> Optional[<a title="nitric.faas.EventContext" href="#nitric.faas.EventContext">EventContext</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this context as an EventContext if it is one, otherwise returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self) -&gt; Union[EventContext, None]:
    &#34;&#34;&#34;Return this context as an EventContext if it is one, otherwise returns None.&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="nitric.faas.TriggerContext.http"><code class="name flex">
<span>def <span class="ident">http</span></span>(<span>self) ‑> Optional[<a title="nitric.faas.HttpContext" href="#nitric.faas.HttpContext">HttpContext</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this context as an HttpContext if it is one, otherwise returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def http(self) -&gt; Union[HttpContext, None]:
    &#34;&#34;&#34;Return this context as an HttpContext if it is one, otherwise returns None.&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nitric" href="index.html">nitric</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nitric.faas.compose_middleware" href="#nitric.faas.compose_middleware">compose_middleware</a></code></li>
<li><code><a title="nitric.faas.event" href="#nitric.faas.event">event</a></code></li>
<li><code><a title="nitric.faas.http" href="#nitric.faas.http">http</a></code></li>
<li><code><a title="nitric.faas.start" href="#nitric.faas.start">start</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nitric.faas.ApiWorkerOptions" href="#nitric.faas.ApiWorkerOptions">ApiWorkerOptions</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.EventContext" href="#nitric.faas.EventContext">EventContext</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.EventContext.event" href="#nitric.faas.EventContext.event">event</a></code></li>
<li><code><a title="nitric.faas.EventContext.from_grpc_trigger_request" href="#nitric.faas.EventContext.from_grpc_trigger_request">from_grpc_trigger_request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.EventRequest" href="#nitric.faas.EventRequest">EventRequest</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.EventRequest.payload" href="#nitric.faas.EventRequest.payload">payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.EventResponse" href="#nitric.faas.EventResponse">EventResponse</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.FaasWorkerOptions" href="#nitric.faas.FaasWorkerOptions">FaasWorkerOptions</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.Frequency" href="#nitric.faas.Frequency">Frequency</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.faas.Frequency.as_str_list" href="#nitric.faas.Frequency.as_str_list">as_str_list</a></code></li>
<li><code><a title="nitric.faas.Frequency.days" href="#nitric.faas.Frequency.days">days</a></code></li>
<li><code><a title="nitric.faas.Frequency.from_str" href="#nitric.faas.Frequency.from_str">from_str</a></code></li>
<li><code><a title="nitric.faas.Frequency.hours" href="#nitric.faas.Frequency.hours">hours</a></code></li>
<li><code><a title="nitric.faas.Frequency.minutes" href="#nitric.faas.Frequency.minutes">minutes</a></code></li>
<li><code><a title="nitric.faas.Frequency.seconds" href="#nitric.faas.Frequency.seconds">seconds</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.FunctionServer" href="#nitric.faas.FunctionServer">FunctionServer</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.FunctionServer.event" href="#nitric.faas.FunctionServer.event">event</a></code></li>
<li><code><a title="nitric.faas.FunctionServer.http" href="#nitric.faas.FunctionServer.http">http</a></code></li>
<li><code><a title="nitric.faas.FunctionServer.start" href="#nitric.faas.FunctionServer.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.HttpContext" href="#nitric.faas.HttpContext">HttpContext</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.HttpContext.from_grpc_trigger_request" href="#nitric.faas.HttpContext.from_grpc_trigger_request">from_grpc_trigger_request</a></code></li>
<li><code><a title="nitric.faas.HttpContext.http" href="#nitric.faas.HttpContext.http">http</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.HttpMethod" href="#nitric.faas.HttpMethod">HttpMethod</a></code></h4>
<ul class="two-column">
<li><code><a title="nitric.faas.HttpMethod.DELETE" href="#nitric.faas.HttpMethod.DELETE">DELETE</a></code></li>
<li><code><a title="nitric.faas.HttpMethod.GET" href="#nitric.faas.HttpMethod.GET">GET</a></code></li>
<li><code><a title="nitric.faas.HttpMethod.OPTIONS" href="#nitric.faas.HttpMethod.OPTIONS">OPTIONS</a></code></li>
<li><code><a title="nitric.faas.HttpMethod.PATCH" href="#nitric.faas.HttpMethod.PATCH">PATCH</a></code></li>
<li><code><a title="nitric.faas.HttpMethod.POST" href="#nitric.faas.HttpMethod.POST">POST</a></code></li>
<li><code><a title="nitric.faas.HttpMethod.PUT" href="#nitric.faas.HttpMethod.PUT">PUT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.HttpRequest" href="#nitric.faas.HttpRequest">HttpRequest</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.HttpRequest.body" href="#nitric.faas.HttpRequest.body">body</a></code></li>
<li><code><a title="nitric.faas.HttpRequest.json" href="#nitric.faas.HttpRequest.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.HttpResponse" href="#nitric.faas.HttpResponse">HttpResponse</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.HttpResponse.body" href="#nitric.faas.HttpResponse.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.MethodOptions" href="#nitric.faas.MethodOptions">MethodOptions</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.MethodOptions.security" href="#nitric.faas.MethodOptions.security">security</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.RateWorkerOptions" href="#nitric.faas.RateWorkerOptions">RateWorkerOptions</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.RateWorkerOptions.description" href="#nitric.faas.RateWorkerOptions.description">description</a></code></li>
<li><code><a title="nitric.faas.RateWorkerOptions.frequency" href="#nitric.faas.RateWorkerOptions.frequency">frequency</a></code></li>
<li><code><a title="nitric.faas.RateWorkerOptions.rate" href="#nitric.faas.RateWorkerOptions.rate">rate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nitric.faas.Request" href="#nitric.faas.Request">Request</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.Response" href="#nitric.faas.Response">Response</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.SubscriptionWorkerOptions" href="#nitric.faas.SubscriptionWorkerOptions">SubscriptionWorkerOptions</a></code></h4>
</li>
<li>
<h4><code><a title="nitric.faas.TriggerContext" href="#nitric.faas.TriggerContext">TriggerContext</a></code></h4>
<ul class="">
<li><code><a title="nitric.faas.TriggerContext.event" href="#nitric.faas.TriggerContext.event">event</a></code></li>
<li><code><a title="nitric.faas.TriggerContext.http" href="#nitric.faas.TriggerContext.http">http</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>